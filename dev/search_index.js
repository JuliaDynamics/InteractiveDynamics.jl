var documenterSearchIndex = {"docs":
[{"location":"cobweb/#Interactive-Cobweb-Diagram-1","page":"Cobweb Diagram","title":"Interactive Cobweb Diagram","text":"","category":"section"},{"location":"cobweb/#","page":"Cobweb Diagram","title":"Cobweb Diagram","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/cobweb.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"cobweb/#","page":"Cobweb Diagram","title":"Cobweb Diagram","text":"interactive_cobweb","category":"page"},{"location":"cobweb/#InteractiveDynamics.interactive_cobweb","page":"Cobweb Diagram","title":"InteractiveDynamics.interactive_cobweb","text":"interactive_cobweb(ds::DiscreteDynamicalSystem, prange, O::Int = 3; kwargs...)\n\nLaunch an interactive application for exploring cobweb diagrams of 1D discrete dynamical systems. Two slides control the length of the plotted trajectory and the current parameter value. The parameter values are obtained from the given prange.\n\nIn the cobweb plot, higher order iterates of the dynamic rule f are plotted as well, starting from order 1 all the way to the given order O. Both the trajectory in the cobweb, as well as any iterate f can be turned off by using some of the buttons.\n\nKeywords\n\nTtr = 0: transient amount of time to evolve before plotting\nfkwargs = [(linewidth = 4.0, color = randomcolor()) for i in 1:O]: plotting keywords for each of the plotted iterates of f\ntrajcolor = randomcolor(): color of the trajectory\npname = \"p\": name of the parameter slider\npindex = 1: parameter index\nxmin = 0, xmax = 1: limits the state of the dynamical system can take\nTmax = 1000: maximum trajectory length\n\n\n\n\n\n","category":"function"},{"location":"cobweb/#","page":"Cobweb Diagram","title":"Cobweb Diagram","text":"The animation at the top of this page was done with","category":"page"},{"location":"cobweb/#","page":"Cobweb Diagram","title":"Cobweb Diagram","text":"using InteractiveDynamics, GLMakie, DynamicalSystems\n\n# the second range is a convenience for intermittency example of logistic\nrrange = 1:0.001:4.0\n# rrange = (rc = 1 + sqrt(8); [rc, rc - 1e-5, rc - 1e-3])\n\nlo = Systems.logistic(0.4; r=rrange[1])\n\ninteractive_cobweb(lo, rrange, 5)","category":"page"},{"location":"od/#Interactive-Orbit-Diagram-1","page":"Orbit Diagram","title":"Interactive Orbit Diagram","text":"","category":"section"},{"location":"od/#","page":"Orbit Diagram","title":"Orbit Diagram","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odhenon.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"od/#","page":"Orbit Diagram","title":"Orbit Diagram","text":"interactive_orbitdiagram\nscaleod","category":"page"},{"location":"od/#InteractiveDynamics.interactive_orbitdiagram","page":"Orbit Diagram","title":"InteractiveDynamics.interactive_orbitdiagram","text":"interactive_orbitdiagram(ds::DiscreteDynamicalSystem, p_index, pmin, pmax, i0 = 1;\n                         u0 = get_state(ds), parname = \"p\", title = \"\")\n\nOpen an interactive application for exploring orbit diagrams (ODs) of discrete dynamical systems. Requires DynamicalSystems.\n\nKeywords control the name of the parameter, the initial state (used for any parameter) or whether to add a title above the orbit diagram.\n\nInteraction\n\nThe application is separated in the \"OD plot\" (left) and the \"control panel\" (right). On the OD plot you can interactively click and drag with the left mouse button to select a region in the OD. This region is then re-computed at a higher resolution.\n\nThe options at the control panel are straight-forward, with\n\nn amount of steps recorded for the orbit diagram (not all are in the zoomed region!)\nt transient steps before starting to record steps\nd density of x-axis (the parameter axis)\nα alpha value for the plotted points.\n\nNotice that at each update n*t*d steps are taken. You have to press update after changing these parameters. Press reset to bring the OD in the original state (and variable). Pressing back will go back through the history of your exploration History is stored when the \"update\" button is pressed or a region is zoomed in.\n\nYou can even decide which variable to get the OD for by choosing one of the variables from the wheel! Because the y-axis limits can't be known when changing variable, they reset to the size of the selected variable.\n\nAccessing the data\n\nWhat is plotted on the application window is a true orbit diagram, not a plotting shorthand. This means that all data are obtainable and usable directly. Internally we always scale the orbit diagram to [0,1]² (to allow Float64 precision even though plotting is Float32-based). This however means that it is necessary to transform the data in real scale. This is done through the function scaleod which accepts the 5 arguments returned from the current function:\n\noddata = interactive_orbitdiagram(...)\nps, us = scaleod(oddata)\n\n\n\n\n\n","category":"function"},{"location":"od/#InteractiveDynamics.scaleod","page":"Orbit Diagram","title":"InteractiveDynamics.scaleod","text":"scaleod(oddata) -> ps, us\n\nGiven the return values of interactive_orbitdiagram, produce orbit diagram data scaled correctly in data units. Return the data as a vector of parameter values and a vector of corresponding variable values.\n\n\n\n\n\n","category":"function"},{"location":"od/#","page":"Orbit Diagram","title":"Orbit Diagram","text":"For example, running","category":"page"},{"location":"od/#","page":"Orbit Diagram","title":"Orbit Diagram","text":"i = p_index = 1\nds, p_min, p_max, parname = Systems.standardmap(), 0.0, 1.2, \"k\"\nt = \"orbit diagram for the standard map\"\n\noddata = interactive_orbitdiagram(ds, p_index, p_min, p_max, i;\n                                  parname = parname, title = t)\n\nps, us = scaleod(oddata)","category":"page"},{"location":"od/#","page":"Orbit Diagram","title":"Orbit Diagram","text":"will produce","category":"page"},{"location":"od/#","page":"Orbit Diagram","title":"Orbit Diagram","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odstandard.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"agents/#Agent-based-models-1","page":"Agent Based Models","title":"Agent based models","text":"","category":"section"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"This page describes functions that can be used in conjunction with Agents.jl to animate and interact with agent based models.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"The animation at the start of this page was done by running the examples/daisyworld.jl file, and see also an example application in Agents.jl docs.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"abm_plot\nabm_play\nabm_video\nabm_data_exploration","category":"page"},{"location":"agents/#InteractiveDynamics.abm_plot","page":"Agent Based Models","title":"InteractiveDynamics.abm_plot","text":"abm_plot(model::ABM; kwargs...) → fig, abmstepper\n\nPlot an agent based model by plotting each individual agent as a marker and using the agent's position field as its location on the plot. Requires Agents.\n\nReturn the overarching fig object, as well as a struct abmstepper that can be used to interactively animate the evolution of the ABM and combine it with other subplots. The figure is not displayed by default, you need to either return fig as a last statement in your functions or simply call display(fig). Notice that models with DiscreteSpace are plotted starting from 0 to n, with n the space size along each dimension.\n\nTo progress the ABM plot n steps simply do:\n\nAgents.step!(abmstepper, model, agent_step!, model_step!, n)\n\nYou can still call this function with n=0 to update the plot for a new model, without doing any stepping. From fig you can obtain the plotted axis (to e.g. turn off ticks, etc.) using ax = content(fig[1, 1]). See Sugarscape for an example of using abmstepper to make an animation of evolving the ABM and a heatmap in parallel with only a few lines of code.\n\nAgent related keywords\n\nac, as, am: These three keywords decided the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a function, which takes as an input a single argument and ouputs the corresponding value. For example:\n# ac = \"#338c54\"\nac(a) = a.status == :S ? \"#2b2b33\" : a.status == :I ? \"#bf2642\" : \"#338c54\"\n# as = 10\nas(a) = 10*randn() + 1\n# am = :diamond\nam(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect\nNotice that am can be/return a Polygon instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent's position when creating the polygon. In this case, the keyword as is meaningless, as each polygon has its own size. Use the functions scale, rotate2D to transform this polygon.\nscheduler = model.scheduler: decides the plotting order of agents (which matters only if there is overlap).\noffset = nothing: If not nothing, it must be a function taking as an input an agent and outputting an offset position vector to be added to the agent's position (which matters only if there is overlap).\nscatterkwargs = (): Additional keyword arguments propagated to the scatter plot. If am is/returns Polygons, then these arguments are propagated to a poly plot.\n\nModel and figure related keywords\n\nheatarray = nothing : A keyword that plots a heatmap over the space. Its values can be standard data accessors given to functions like run!, i.e. either a symbol (directly obtain model property) or a function of the model. The returned data must be a matrix of the same size as the underlying space. For example heatarray = :temperature is used in the Daisyworld example. But you could also define f(model) = create_some_matrix_from_model... and set heatarray = f. The heatmap will be updated automatically during model evolution in videos and interactive applications.\nheatkwargs = (colormap=:tokyo,) : Keyowrds given to Makie.heatmap function if heatarray is not nothing.\naspect = DataAspect(): The aspect ratio behavior of the axis.\nresolution = (600, 600): Resolution of the figugre.\nstatic_preplot! : A function f(ax, model) that plots something after the heatmap but before the agents. Notice that you can still make objects of this plot be visible above the agents using a translation in the third dimension like below:\nfunction static_preplot!(ax, model)\n    obj = CairoMakie.scatter!([50 50]; color = :red) # Show position of teacher\n    CairoMakie.hidedecorations!(ax) # hide tick labels etc.\n    CairoMakie.translate!(obj, 0, 0, 5) # be sure that the teacher will be above students\nend\n\n\n\n\n\n","category":"function"},{"location":"agents/#InteractiveDynamics.abm_play","page":"Agent Based Models","title":"InteractiveDynamics.abm_play","text":"abm_play(model, agent_step!, model_step!; kwargs...) → fig, abmstepper\n\nLaunch an interactive application that plots an agent based model and can animate its evolution in real time. Requires Agents.\n\nThe agents are plotted exactly like in abm_plot, while the two functions agent_step!, model_step! decide how the model will evolve, as in the standard approach of Agents.jl and its step! function.\n\nThe application has two buttons: \"run\" and \"reset\" which starts/stops the time evolution and resets the model to its original configuration. Two sliders control the animation speed: \"spu\" decides how many model steps should be done before the plot is updated, and \"sleep\" the sleep() time between updates.\n\nKeywords\n\nac, am, as, scheduler, offset, aspect, scatterkwargs: propagated to abm_plot.\nspu = 1:100: The values of the \"spu\" slider.\n\n\n\n\n\n","category":"function"},{"location":"agents/#InteractiveDynamics.abm_video","page":"Agent Based Models","title":"InteractiveDynamics.abm_video","text":"abm_video(file, model, agent_step! [, model_step!]; kwargs...)\n\nThis function exports the animated time evolution of an agent based model into a video saved at given path file, by recording the behavior of abm_play (without sliders). The plotting is identical as in abm_plot.\n\nKeywords\n\nspf = 1: Steps-per-frame, i.e. how many times to step the model before recording a new frame.\nframerate = 30: The frame rate of the exported video.\nframes = 300: How many frames to record in total, including the starting frame.\nresolution = (600, 600): Resolution of the fig.\naxiskwargs = NamedTuple(): Keyword arguments given to the main axis creation for e.g. setting xticksvisible = false.\nkwargs...: All other keywords are propagated to abm_plot.\n\n\n\n\n\n","category":"function"},{"location":"agents/#InteractiveDynamics.abm_data_exploration","page":"Agent Based Models","title":"InteractiveDynamics.abm_data_exploration","text":"abm_data_exploration(model::ABM, agent_step!, model_step!, params=Dict(); kwargs...)\n\nOpen an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires Agents.\n\nThe application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in abm_play, and the arguments model, agent_step!, model_step! are propagated there as-is.\n\nCalling abm_data_exploration returns: figure, agent_df, model_df. So you can save the figure, but you can also access the collected data (if any).\n\nInteraction\n\nBesides the basic time evolution interaction of abm_play, additional functionality here allows changing model parameters in real time, based on the provided fourth argument params. This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of params is a pair of Symbol to an AbstractVector, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only updated into the actual model when pressing the \"update\" button.\n\nThe \"reset\" button resets the model to its original agent and space state but it updates it to the currently selected parameter values. A red vertical line is displayed in the data plots when resetting, for visual guidance.\n\nKeywords\n\nac, am, as, scheduler, offset, aspect, scatterkwargs: propagated to abm_plot.\nadata, mdata: Same as the keyword arguments of Agents.run!, and decide which data of the model/agents will be collected and plotted below the interactive plot. Notice that data collection can only occur on plotted steps (and thus steps not plotted due to \"spu\" are also not data-collected).\nalabels, mlabels: If data are collected from agents or the model with adata, mdata, the corresponding plots have a y-label named after the collected data. Instead, you can give alabels, mlabels (vectors of strings with exactly same length as adata, mdata), and these labels will be used instead.\nwhen = true: When to perform data collection, as in Agents.run!.\nspu = 1:100: Values that the \"spu\" slider will obtain.\n\n\n\n\n\n","category":"function"},{"location":"highlight/#Trajectory-Highlighter-1","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"","category":"section"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"trajectory_highlighter","category":"page"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"2D Version:","category":"page"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/highlighter2D.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"3D Version:","category":"page"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/highlighter3D.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"brainscan/#Interactive-Cobweb-Diagram-1","page":"Brainscanning PSOS","title":"Interactive Cobweb Diagram","text":"","category":"section"},{"location":"brainscan/#","page":"Brainscanning PSOS","title":"Brainscanning PSOS","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/psos_brainscan.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"brainscan/#","page":"Brainscanning PSOS","title":"Brainscanning PSOS","text":"brainscan_poincaresos","category":"page"},{"location":"brainscan/#InteractiveDynamics.brainscan_poincaresos","page":"Brainscanning PSOS","title":"InteractiveDynamics.brainscan_poincaresos","text":"brainscan_poincaresos(A::Dataset, j::Int)\n\nLaunch an interactive application for scanning a Poincare surface of section of A like a \"brain scan\", where the plane that defines the section can be arbitrarily moved around via a slider. Return figure, ax3D, ax2D.\n\nThe input dataset must be 3 dimensional, and here the crossing plane is always chosen to be when the j-th variable of the dataset crosses a predefined value. The slider automatically gets all possible values the j-th variable can obtain.\n\nThe keywords linekw, scatterkw are named tuples or dictionaries that are propagated to as keyword arguments to the line and scatter plot respectively, while the keyword direction = -1 is propagated to the function DyamicalSystems.poincaresos.\n\n\n\n\n\n","category":"function"},{"location":"brainscan/#","page":"Brainscanning PSOS","title":"Brainscanning PSOS","text":"The animation at the top of this page was done with","category":"page"},{"location":"brainscan/#","page":"Brainscanning PSOS","title":"Brainscanning PSOS","text":"using GLMakie, DynamicalSystems, InteractiveDynamics\nusing OrdinaryDiffEq\n\nds = Systems.henonheiles()\ndiffeq = (alg = Vern9(),)\nu0s = [\n    [0.0, -0.25, 0.42081, 0.0],\n    [0.0, 0.1, 0.5, 0.0],\n    [0.0, -0.31596, 0.354461, 0.0591255]\n]\ntrs = [trajectory(ds, 10000, u0; diffeq...)[:, SVector(1,2,3)] for u0 ∈ u0s]\nfor i in 2:length(u0s)\n    append!(trs[1], trs[i])\nend\n\n# Inputs:\nj = 2 # the dimension of the plane\ntr = trs[1]\n\nbrainscan_poincaresos(tr, j)","category":"page"},{"location":"billiards/#Billiards-1","page":"Billiards","title":"Billiards","text":"","category":"section"},{"location":"billiards/#Interactive-billiard-1","page":"Billiards","title":"Interactive billiard","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/bill2.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"(see the examples/billiard.jl file to generate every animation)","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"interactive_billiard","category":"page"},{"location":"billiards/#InteractiveDynamics.interactive_billiard","page":"Billiards","title":"InteractiveDynamics.interactive_billiard","text":"interactive_billiard(bd::Billiard [, x, y, φ] [, ω=nothing]; kwargs...)\ninteractive_billiard(bd::Billiard, ps::Vector{<:AbstractParticle}; kwargs...)\n\nLaunch an interactive application that evolves particles in a dynamical billiard bd, using DynamicalBilliards.jl. Requires DynamicalBilliards.\n\nYou can either specify exactly the particles that will be used ps or provide some initial conditions x,y,φ,ω, which by default are random in the billiard. The particles are evolved in real time instead of being pre-calculated, so the application can be left to run for infinite time.\n\nSee also interactive_billiard_bmap and billiard_video.\n\nInteraction\n\nPush \"play\" to start evolving particles in the billiard, and \"reset\" to restore them to their (latest) initial condition. The \"particles\" hides or shows the particles. The \"speed\" slider controls the animation speed (in fact, it controls how often are the plots updated).\n\nClicking and dragging inside the billiard plot shows a line. When the line is selected, new particles are created that have the direction of this line, as well as its starting position, using the function particlebeam from DynamicalBilliards.\n\nFurther keywords\n\nN = 100 : if exact particles are not given, N are created. Otherwise it is length(ps).\ndx = 0.01 : width of the particle beam.\ndt = 0.001 : time resolution of the animation.\ntail = 1000 : length of the tail of the particles (multiplies dt).\ncolors = JULIADYNAMICS_COLORS : If a symbol (colormap name) each particle gets a color from the map. If Vector of length N, each particle gets a color form the vector. If Vector with length < N, linear interpolation across contained colors is done.\ntailwidth = 1 : Linewidth of the particle tail.\nfade = true : Whether to add fadeout to the particle tail.\nsleept = nothing : If the slowest speed of the animation is already too fast, give a small number to sleept.\nplot_particles = true : If false, the particles are not plotted (as balls and arrows). This makes the application faster (you cannot show them again with the button).\nparticle_size = 1.0 A multiplier for the size of the particles.\n\n\n\n\n\n","category":"function"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"For example, running","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, GLMakie\nbd, = billiard_logo(T = Float32)\ninteractive_billiard(bd, 1f0, tail = 1000)","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"gives","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/bill1.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"billiards/#Billiard-video-1","page":"Billiards","title":"Billiard video","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"billiard_video","category":"page"},{"location":"billiards/#InteractiveDynamics.billiard_video","page":"Billiards","title":"InteractiveDynamics.billiard_video","text":"billiard_video(file, bd::Billiard [, x, y, φ] [, ω=nothing]; kwargs...)\nbilliard_video(file, bd::Billiard, ps::Vector{<:AbstractParticle}; kwargs...)\n\nPerform the same animation like in interactive_billiard, but there is no interaction; the result is saved directly as a video in file (no buttons are shown).\n\nKeywords\n\nN, dt, tail, dx, colors, plot_particles, fade, tailwidth, backgroundcolor: same as in interactive_billiard, but plot_particles is false by default here.\nspeed = 5: Animation \"speed\" (how many dt steps are taken before a frame is recorded)\nframes = 1000: amount of frames to record.\nframerate = 60: exported framerate.\nres = nothing: resolution of the frames. If nothing, a resolution matching the the billiard aspect ratio is estimated. Otherwise pass a 2-tuple.\n\nNotice that the animation performs an extra step for every speed steps and the first frame saved is always at time 0. Therefore the following holds:\n\ntotal_time = (frames-1)*(speed+1)*dt\ntime_covered_per_frame = (speed+1)*dt\n\n\n\n\n\n","category":"function"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"Here is a video in the style of 3Blue1Brown","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/3b1billiard.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"billiards/#Video-with-timeseries-1","page":"Billiards","title":"Video with timeseries","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"billiard_video_timeseries","category":"page"},{"location":"billiards/#InteractiveDynamics.billiard_video_timeseries","page":"Billiards","title":"InteractiveDynamics.billiard_video_timeseries","text":"billiard_video_timeseries(file, bd::Billiard, ps, f; kwargs...)\n\nPerform the same animation like in billiard_video, but in addition show the timeseries of a chosen observable above the billiard. The observable is given using the function f, which takes as an input a particle and outputs the observable. E.g. f(p) = p.pos[2] or f(p) = atan(p.vel[2], p.vel[1]). The video is saved directly into file.\n\nKeywords\n\nN, dt, tail, dx, colors, plot_particles, fade, tailwidth, backgroundcolor: same as in interactive_billiard.\nspeed, frames, framerate, res: As in billiard_video.\ntotal_span = 10.0: Total span of the x-axis of the timeseries plot in real time units.\nylim = (0, 1): Limits of the y-axis of the timeseries plot.\nylabel = \"f\": Label of the y-axis of the timeseries plot.\n\n\n\n\n\n","category":"function"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"For example running","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using InteractiveDynamics, DynamicalBilliards, GLMakie\n\npsize = 2.0\n\nbd = billiard_stadium(1.0f0, 1.0f0) # must be type Float32\n\nframes = 1800\ndt = 0.0001\nspeed = 200\nf(p) = p.pos[2] # the function that obtains the data from the particle\ntotal_span = 10.0\n\nps = particlebeam(1.0, 0.8, 0, 2, 0.0001, nothing, Float32)\nylim = (0, 1)\nylabel = \"y\"\n\nbilliard_video_timeseries(\n    videodir(\"timeseries.mp4\"), bd, ps, f;\n    displayfigure = true, total_span,\n    frames, backgroundcolor = :black,\n    plot_particles = true, tailwidth = 4, particle_size = psize, res = MAXRES,\n    dt, speed, tail = 20000, # this makes ultra fine temporal resolution\n    framerate = 60, ylabel\n)","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"gives","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/billiard_timeseries.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"billiards/#Interactive-with-boundary-map-1","page":"Billiards","title":"Interactive with boundary map","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"interactive_billiard_bmap","category":"page"},{"location":"billiards/#InteractiveDynamics.interactive_billiard_bmap","page":"Billiards","title":"InteractiveDynamics.interactive_billiard_bmap","text":"interactive_billiard_bmap(bd::Billiard, ω=nothing; kwargs...)\n\nLaunch an interactive application whose left part is interactive_billiard and whose write part is an interactive boundary map of the billiard (see \"Phase spaces\" in DynamicalBilliards.jl).\n\nA particle evolved in the real billiard is also shown on the boundary map. All interaction of the billiard works as before, but there is also interaction in the boundary map: clicking on it will generate a particle whose boundary map is the clicked point.\n\nThe mean collision time \"m.c.t.\" of the particle is shown as well.\n\nKeywords\n\nnewcolor = randomcolor A function which takes as input (pos, vel, ξ, sφ) and outputs a color (for the scatter points in the boundary map).\nms = 12 markersize (in pixels).\ndt, tail, sleept, fade : propagated to interactive_billiard.\n\n\n\n\n\n","category":"function"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/bmap.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"billiards/#Static-plot-with-boundary-map-1","page":"Billiards","title":"Static plot with boundary map","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"billiard_bmap_plot","category":"page"},{"location":"billiards/#InteractiveDynamics.billiard_bmap_plot","page":"Billiards","title":"InteractiveDynamics.billiard_bmap_plot","text":"billiard_bmap_plot(bd::Billiard, ps::Vector{<:AbstractParticle}; kwargs...)\n\nReturn a static figure which has particles plotted on both the real billiard as well the boundary map, each with its own color (keyword colors), and the same color is used for the corresponding scatter points in the boundary map.\n\nAll keyword arguments are the same as interactive_billiard_bmap, besides the interaction part of course. The additional keyword steps counts how many times to progress the particles (in multiples of dt).\n\n\n\n\n\n","category":"function"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"InteractiveDynamics is a package that provides applications for interactively exploring dynamical systems. It extends various packages of JuliaDynamics.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: Example animations\nAll of the animations/videos you will see in this documentation are generated by simply running the scripts of the examples folder of InteractiveDynamics.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Here are some examples of what you can do with InteractiveDynamics (see Index below, or the various pages of the side bar for full list of applications)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Dynamical systems","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<video width=\"75%\" height=\"auto\" controls loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odhenon.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Billiards","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<video width=\"75%\" height=\"auto\" controls loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/bmap.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Agent based models","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<video width=\"75%\" height=\"auto\" controls loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#Description-1","page":"Introduction","title":"Description","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"InteractiveDynamics is a Julia package that builds on top of the packages of JuliaDynamics to create interactive applications for dynamical systems of all kinds. It is written exclusively in Julia, taking advantage of the interactive plotting that GLMakie.jl provides. InteractiveDynamics is great for teaching and demonstrations, but we believe that it can also be taken advantage of in research.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The combination of the following properties make InteractiveDynamics a unique software:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"General purpose. Arguably the most unique feature of InteractiveDynamics is that every application it offers works for any dynamical system (for the class it targets). The first app shown in the introduction works for any discrete system (of any dimensions), the second app works for any 2D billiard of any shape, the third app works for any 2D agent based model (in discrete or continuous space). This happens because InteractiveDynamics interfaces existing software for dynamical systems from JuliaDynamics. This means that you can re-use the system that you analyze scientifically and explore it interactively, typically requiring only 5-10 extra lines of code to launch the application.\nFast. Because internally some of the fastest dynamical systems software and some of the fastest plotting software are used, this makes our applications extremely fast, given the amount of computations and plotted data they handle.\nReal data. Everything that is plotted is real. For example, the first application shown plots the true orbit diagram (which means that the alpha value is actually the value of the natural density), instead of a pixelated short-hand that allows faster plotting. Since real-data are computed, they are also returned to the user. This means that if the user finds something interesting at any stage of interacting with the application, they can immediately analyze the results in a more thorough and rigorous manner.\nIn real time.  Most applications of InteractiveChaso calculate everything in real-time. This allows true real time interactivity: at any point some model parameter may change and this change will be immediately reflected into the visualizations. Another important consequence of doing calculations in real time is that all applications of InteractiveDynamics can evolve dynamical systems potentially forever.\nSmall source code The entire source code for e.g. the orbit diagram plot is 200 lines of code, all clear to understand (we hope), allowing one to expand the existing apps, or to make more specialized versions.","category":"page"},{"location":"#Usage-1","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Using InteractiveDynamics is straightforward, and the documentation strings of the exported functions describe in detail their purpose (see the individual pages of the sidebar).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Each application relies on a package of JuliaDynamics, and thus it requires it to run. For example, if you want to use the function interactive_orbitdiagram, then you must also load DynamicalSystems besides InteractiveDynamics, e.g.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using DynamicalSystems, InteractiveDynamics, GLMakie\n\nds = Systems.some_example_system()\n\ninteractive_psos(ds, ...)","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"To install do ]add InteractiveDynamics GLMakie. GLMakie is necessary for providing a plotting backend, since InteractiveDynamics does not install one by default.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"It is expected that you have the latest (stable) versions installed for the library you want to use, e.g. DynamicalSystems.","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Modules = [InteractiveDynamics]\nOrder   = [:function, :type]","category":"page"},{"location":"psos/#Interactive-Poincaré-Surface-of-Section-1","page":"Poincaré Surface of Section","title":"Interactive Poincaré Surface of Section","text":"","category":"section"},{"location":"psos/#","page":"Poincaré Surface of Section","title":"Poincaré Surface of Section","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_psos.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"psos/#","page":"Poincaré Surface of Section","title":"Poincaré Surface of Section","text":"interactive_poincaresos","category":"page"},{"location":"psos/#InteractiveDynamics.interactive_poincaresos","page":"Poincaré Surface of Section","title":"InteractiveDynamics.interactive_poincaresos","text":"interactive_poincaresos(cds, plane, idxs, complete; kwargs...)\n\nLaunch an interactive application for exploring a Poincaré surface of section (PSOS) of the continuous dynamical system cds. Requires DynamicalSystems.\n\nThe plane can only be the Tuple type accepted by DynamicalSystems.poincaresos, i.e. (i, r) for the ith variable crossing the value r. idxs gives the two indices of the variables to be displayed, since the PSOS plot is always a 2D scatterplot. I.e. idxs = (1, 2) will plot the 1st versus 2nd variable of the PSOS. It follows that plane[1] ∉ idxs must be true.\n\ncomplete is a three-argument function that completes the new initial state during interactive use, see below.\n\nThe function returns: figure, laststate with the latter being an observable containing the latest initial state.\n\nKeyword Arguments\n\ndirection, rootkw : Same use as in DynamicalSystems.poincaresos.\ntfinal = (1000.0, 10.0^4) : A 2-element tuple for the range of values for the total integration time (chosen interactively).\ncolor : A function of the system's initial condition, that returns a color to plot the new points with. The color must be RGBf0/RGBAf0.  A random color is chosen by default.\nlabels = (\"u₁\" , \"u₂\") : Scatter plot labels.\nscatterkwargs = (): Named tuple of keywords passed to scatter.\ndiffeq... : Any extra keyword arguments are passed into init of DiffEq.\n\nInteraction\n\nThe application is a standard scatterplot, which shows the PSOS of the system, initially using the system's u0. Two sliders control the total evolution time and the size of the marker points (which is always in pixels).\n\nUpon clicking within the bounds of the scatter plot your click is transformed into a new initial condition, which is further evolved and its PSOS is computed and then plotted into the scatter plot.\n\nYour click is transformed into a full D-dimensional initial condition through the function complete. The first two arguments of the function are the positions of the click on the PSOS. The third argument is the value of the variable the PSOS is defined on. To be more exact, this is how the function is called:\n\nx, y = mouseclick; z = plane[2]\nnewstate = complete(x, y, z)\n\nThe complete function can throw an error for ill-conditioned x, y, z. This will be properly handled instead of breaking the application. This newstate is also given to the function color that gets a new color for the new points.\n\n\n\n\n\n","category":"function"},{"location":"psos/#","page":"Poincaré Surface of Section","title":"Poincaré Surface of Section","text":"","category":"page"},{"location":"psos/#","page":"Poincaré Surface of Section","title":"Poincaré Surface of Section","text":"To generate the video at the start of this page you can run","category":"page"},{"location":"psos/#","page":"Poincaré Surface of Section","title":"Poincaré Surface of Section","text":"using InteractiveDynamics, GLMakie, OrdinaryDiffEq, DynamicalSystems\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\n\nhh = Systems.henonheiles()\n\npotential(x, y) = 0.5(x^2 + y^2) + (x^2*y - (y^3)/3)\nenergy(x,y,px,py) = 0.5(px^2 + py^2) + potential(x,y)\nconst E = energy(get_state(hh)...)\n\nfunction complete(y, py, x)\n    V = potential(x, y)\n    Ky = 0.5*(py^2)\n    Ky + V ≥ E && error(\"Point has more energy!\")\n    px = sqrt(2(E - V - Ky))\n    ic = [x, y, px, py]\n    return ic\nend\n\nplane = (1, 0.0) # first variable crossing 0\n\n# %% Coloring points using the Lyapunov exponent\nfunction λcolor(u)\n    λ = lyapunovs(hh, 4000; u0 = u)[1]\n    λmax = 0.1\n    return RGBf0(0, 0, clamp(λ/λmax, 0, 1))\nend\n\nstate, scene = interactive_poincaresos(hh, plane, (2, 4), complete;\nlabels = (\"q₂\" , \"p₂\"),  color = λcolor, diffeq...)","category":"page"},{"location":"trajectory/#Interactive-trajectory-evolution-1","page":"Trajectory Evolution","title":"Interactive trajectory evolution","text":"","category":"section"},{"location":"trajectory/#Without-timeseries-1","page":"Trajectory Evolution","title":"Without timeseries","text":"","category":"section"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_trajectory.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"interactive_evolution","category":"page"},{"location":"trajectory/#InteractiveDynamics.interactive_evolution","page":"Trajectory Evolution","title":"InteractiveDynamics.interactive_evolution","text":"interactive_evolution(ds::DynamicalSystem, u0s; kwargs...)\n\nLaunch an interactive application that can evolve the initial conditions u0s (vector of vectors) of the given dynamical system. All initial conditions are evolved in parallel and at exactly the same time. Two controls allow you to pause/resume the evolution and to adjust the speed. The application can run forever (trajectories are computed on demand).\n\nThe function returns figure, obs. figure is the overarching figure (the entire GUI) and can be recorded. obs is a vector of observables, each containing the current state of the trajectory.\n\nKeywords\n\ntransform = identity : Transformation applied to the state of the dynamical system before plotting. Can even return a vector that is of higher dimension than ds.\nidxs = 1:min(length(transform(ds.u0)), 3) : Which variables to plot (up to three can be chosen). Variables are selected after transform has been applied.\ncolors : The color for each trajectory. Random colors are chosen by default.\nlims : A tuple of tuples (min, max) for the axis limits. If not given, they are automatically deduced by evolving each of u0s 1000 units and picking most extreme values (limits cannot be adjust after application is launched).\nm = 1.0 : The trajectory endpoints have a marker. A heuristic is done to choose appropriate marker size given the trajectory size. m is a multiplier that scales the marker size.\nplotkwargs = NamedTuple() : A named tuple of keyword arguments propagated to the plotting function (lines for continuous, scatter for discrete systems). plotkwargs can also be a vector of named tuples, in which case each initial condition gets different arguments.\ntail = 1000 : Length of plotted trajectory (in step units).\ndiffeq = DynamicalSystems.CDS_KWARGS : Named tuple of keyword arguments propagated to the solvers of DifferentialEquations.jl (for continuous systems). Because trajectories are not pre-computed and interpolated, it is recommended to use a combination of arguments that limit maximum stepsize, to ensure smooth curves. For example:\nusing OrdinaryDiffEq\ndiffeq = (alg = Tsit5(), dtmax = 0.01)\n\n\n\n\n\n","category":"function"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"To generate the video at the start of this page run","category":"page"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"using InteractiveDynamics\nusing DynamicalSystems, GLMakie\nusing OrdinaryDiffEq\n\nds = Systems.henonheiles()  # 4D chaotic/regular continuous system\n\nu0s = [[0.0, -0.25, 0.42081, 0.0],\n[0.0, 0.1, 0.5, 0.0],\n[0.0, -0.31596, 0.354461, 0.0591255]]\n\ndiffeq = (alg = Vern9(), dtmax = 0.01)\nidxs = (1, 2, 4)\ncolors = [\"#233B43\", \"#499cbf\", \"#E84646\"]\n\nfigure, obs = interactive_evolution(\n    ds, u0s; idxs, tail = 10000, diffeq, colors\n)","category":"page"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"And here is another version for a discrete system:","category":"page"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"using InteractiveDynamics\nusing DynamicalSystems, GLMakie\n\nds = Systems.towel() # 3D chaotic discrete system\nu0s = [0.1ones(3) .+ 1e-3rand(3) for _ in 1:3]\n\nfigure, obs = interactive_evolution(\n    ds, u0s; idxs = SVector(1, 2, 3), tail = 100000,\n)","category":"page"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/towel_trajectory.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"trajectory/#With-timeseries-1","page":"Trajectory Evolution","title":"With timeseries","text":"","category":"section"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_trajectory_timeseries.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"trajectory/#","page":"Trajectory Evolution","title":"Trajectory Evolution","text":"interactive_evolution_timeseries","category":"page"},{"location":"trajectory/#InteractiveDynamics.interactive_evolution_timeseries","page":"Trajectory Evolution","title":"InteractiveDynamics.interactive_evolution_timeseries","text":"interactive_evolution_timeseries(args...; kwargs...)\n\nExactly like interactive_evolution, but in addition to the state space plot a panel with the timeseries is also plotted and animated in real time.\n\nThe following additional keywords apply:\n\ntotal_span : How much the x-axis of the timeseries plots should span (in real time units)\nlinekwargs = NamedTuple() : Extra keywords propagated to the timeseries plots.\n\n\n\n\n\n","category":"function"}]
}
