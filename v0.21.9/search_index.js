var documenterSearchIndex = {"docs":
[{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"EditURL = \"https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/main/docs/src/agents.jl\"","category":"page"},{"location":"agents/#Visualizations-and-Animations-for-Agent-Based-Models-1","page":"Agent Based Models","title":"Visualizations and Animations for Agent Based Models","text":"","category":"section"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"This page describes functions that can be used in conjunction with Agents.jl to animate and interact with agent based models.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"The animation at the start of the page is created using the code of this page, see below.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"The docs are built using versions:","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"using Pkg\nPkg.status([\"Agents\", \"InteractiveDynamics\", \"CairoMakie\"];\n    mode = PKGMODE_MANIFEST, io=stdout\n)","category":"page"},{"location":"agents/#Static-plotting-of-ABMs-1","page":"Agent Based Models","title":"Static plotting of ABMs","text":"","category":"section"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"Static plotting, which is also the basis for creating custom plots that include an abm plot, is done using the abmplot function. Its usage is exceptionally straight-forward, and in principle one simply defines functions for how the agents should be plotted. Here we will use a pre-defined model, the Daisyworld as an example throughout this docpage. To learn about this model you can visit the full example,","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"using InteractiveDynamics, Agents\nusing CairoMakie\ndaisypath = joinpath(dirname(pathof(InteractiveDynamics)), \"agents\", \"daisyworld_def.jl\")\ninclude(daisypath)\nmodel, daisy_step!, daisyworld_step! = daisyworld(;\n    solar_luminosity = 1.0, solar_change = 0.0, scenario = :change\n)\nmodel","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"Now, to plot daisyworld is as simple as","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"daisycolor(a::Daisy) = a.breed # color of agents\nas = 20 # size of agents\nam = '✿' # marker of agents\nscatterkwargs = (strokewidth = 1.0,) # add stroke around each agent\nfig, ax, abmobs = abmplot(model; ac = daisycolor, as, am, scatterkwargs)\nfig","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"To this, we can also plot the temperature of the planet by providing the access field as a heat array:","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"heatarray = :temperature\nheatkwargs = (colorrange = (-20, 60), colormap = :thermal)\nplotkwargs = (;\n    ac = daisycolor, as, am,\n    scatterkwargs = (strokewidth = 1.0,),\n    heatarray, heatkwargs\n)\n\nfig, ax, abmobs = abmplot(model; plotkwargs...)\nfig","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"abmplot","category":"page"},{"location":"agents/#InteractiveDynamics.abmplot","page":"Agent Based Models","title":"InteractiveDynamics.abmplot","text":"abmplot(model::ABM; kwargs...) → fig, ax, abmobs\nabmplot!(ax::Axis/Axis3, model::ABM; kwargs...) → abmobs\n\nPlot an agent based model by plotting each individual agent as a marker and using the agent's position field as its location on the plot. The same function is used to make custom composite plots and interactive applications for the model evolution using the returned abmobs. abmplot is also used to launch interactive GUIs for evolving agent based models, see \"Interactivity\" below.\n\nRequires Agents. See also abmvideo and abmexploration.\n\nKeyword arguments\n\nAgent related\n\nac, as, am : These three keywords decide the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a function, which takes as an input a single agent and outputs the corresponding value.\nUsing constants: ac = \"#338c54\", as = 15, am = :diamond\nUsing functions:\nac(a) = a.status == :S ? \"#2b2b33\" : a.status == :I ? \"#bf2642\" : \"#338c54\"\nas(a) = 10rand()\nam(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect\nNotice that for 2D models, am can be/return a Polygon instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent's position when creating the polygon. In this case, the keyword as is meaningless, as each polygon has its own size. Use the functions scale, rotate2D to transform this polygon.\n3D models currently do not support having different markers. As a result, am cannot be a function. It should be a Mesh or 3D primitive (such as Sphere or Rect3D).\noffset = nothing : If not nothing, it must be a function taking as an input an agent and outputting an offset position tuple to be added to the agent's position (which matters only if there is overlap).\nscatterkwargs = () : Additional keyword arguments propagated to the scatter! call.\n\nPreplot related\n\nheatarray = nothing : A keyword that plots a heatmap over the space. Its values can be standard data accessors given to functions like run!, i.e. either a symbol (directly obtain model property) or a function of the model. The returned data must be a matrix of the same size as the underlying space. For example heatarray = :temperature is used in the Daisyworld example. But you could also define f(model) = create_matrix_from_model... and set heatarray = f. The heatmap will be updated automatically during model evolution in videos and interactive applications.\nIt is strongly recommended to use abmplot instead of the abmplot! method if you use heatarray, so that a colorbar can be placed naturally.\nheatkwargs = NamedTuple() : Keywords given to Makie.heatmap function if heatarray is not nothing.\nadd_colorbar = true : Whether or not a Colorbar should be added to the right side of the heatmap if heatarray is not nothing.\nstatic_preplot! : A function f(ax, model) that plots something after the heatmap but before the agents.\nosmkwargs = NamedTuple() : keywords directly passed to osmplot! from OSMMakie.jl if model space is OpenStreetMapSpace.\n\nThe stand-alone function abmplot also takes two optional NamedTuples named figure and axis which can be used to change the automatically created Figure and Axis objects.\n\nInteractivity\n\nEvolution related\n\nagent_step!, model_step! = Agents.dummystep: Stepping functions to pass to ABMObservable which itself passes to Agents.step!.\nadd_controls::Bool: If true, abmplot switches to \"interactive application\" mode. This is by default true if either agent_step! or model_step! keywords are provided. These stepping functions are used to evolve the model interactively using Agents.step!. The application has the following interactive elements:\n\"step\": advances the simulation once for spu steps.\n\"run\": starts/stops the continuous evolution of the model.\n\"reset model\": resets the model to its initial state from right after starting the interactive application.\nTwo sliders control the animation speed: \"spu\" decides how many model steps should be done before the plot is updated, and \"sleep\" the sleep() time between updates.\nenable_inspection = add_controls: If true, enables agent inspection on mouse hover.\nspu = 1:50: The values of the \"spu\" slider.\nparams = Dict() : This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of params is a pair of Symbol to an AbstractVector, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only propagated to the actual model after a press of the \"update\" button.\n\nData collection related\n\nadata, mdata, when: Same as the keyword arguments of Agents.run!. If either or both adata, mdata are given, data are collected and stored in the abmobs, see ABMObservable. The same keywords provide the data plots of abmexploration. This also adds the button \"clear data\" which deletes previously collected agent and model data by emptying the underlying DataFrames adf/mdf. Reset model and clear data are independent processes.\n\nSee the documentation string of ABMObservable for custom interactive plots.\n\n\n\n\n\n","category":"function"},{"location":"agents/#Interactive-ABM-Applications-1","page":"Agent Based Models","title":"Interactive ABM Applications","text":"","category":"section"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"Continuing from the Daisyworld plots above, we can turn them into interactive applications straightforwardly, simply by providing the stepping functions as illustrated in the documentation of abmplot. Note that GLMakie should be used instead of CairoMakie when wanting to use the interactive aspects of the plots.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"fig, ax, abmobs = abmplot(model;\n    agent_step! = daisy_step!, model_step! = daisyworld_step!,\n    plotkwargs...)\nfig","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"One could click the run button and see the model evolve. Furthermore, one can add more sliders that allow changing the model parameters.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"params = Dict(\n    :surface_albedo => 0:0.01:1,\n    :solar_change => -0.1:0.01:0.1,\n)\nfig, ax, abmobs = abmplot(model;\n    agent_step! = daisy_step!, model_step! = daisyworld_step!,\n    params, plotkwargs...)\nfig","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"One can furthermore collect data while the model evolves and visualize them using the convenience function abmexploration","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"using Statistics: mean\nblack(a) = a.breed == :black\nwhite(a) = a.breed == :white\nadata = [(black, count), (white, count)]\ntemperature(model) = mean(model.temperature)\nmdata = [temperature, :solar_luminosity]\nfig, abmobs = abmexploration(model;\n    agent_step! = daisy_step!, model_step! = daisyworld_step!, params, plotkwargs...,\n    adata, alabels = [\"Black daisys\", \"White daisys\"], mdata, mlabels = [\"T\", \"L\"]\n)\nnothing # hide","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"abmexploration","category":"page"},{"location":"agents/#InteractiveDynamics.abmexploration","page":"Agent Based Models","title":"InteractiveDynamics.abmexploration","text":"abmexploration(model::ABM; alabels, mlabels, kwargs...)\n\nOpen an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires Agents.\n\nThe application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in abmplot, and the model argument as well as splatted kwargs are propagated there as-is. This convencience function only works for aggregated agent data.\n\nCalling abmexploration returns: fig::Figure, p::_ABMPlot. So you can save and/or further modify the figure. But it is also possible to access the collected data (if any) via the plot object, just like in the case of using abmplot directly.\n\nClicking the \"reset\" button will add a red vertical line to the data plots for visual guidance.\n\nKeywords arguments (in addition to those in abmplot)\n\nalabels, mlabels: If data are collected from agents or the model with adata, mdata, the corresponding plots' y-labels are automatically named after the collected data. It is also possible to provide alabels, mlabels (vectors of strings with exactly same length as adata, mdata), and these labels will be used instead.\nfigure = NamedTuple(): Keywords to customize the created Figure.\naxis = NamedTuple(): Keywords to customize the created Axis.\nplotkwargs = NamedTuple(): Keywords to customize the styling of the resulting scatterlines plots.\n\n\n\n\n\n","category":"function"},{"location":"agents/#ABM-Videos-1","page":"Agent Based Models","title":"ABM Videos","text":"","category":"section"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"abmvideo","category":"page"},{"location":"agents/#InteractiveDynamics.abmvideo","page":"Agent Based Models","title":"InteractiveDynamics.abmvideo","text":"abmvideo(file, model, agent_step! [, model_step!]; kwargs...)\n\nThis function exports the animated time evolution of an agent based model into a video saved at given path file, by recording the behavior of the interactive version of abmplot (without sliders). The plotting is identical as in abmplot and applicable keywords are propagated.\n\nKeywords\n\nspf = 1: Steps-per-frame, i.e. how many times to step the model before recording a new frame.\nframerate = 30: The frame rate of the exported video.\nframes = 300: How many frames to record in total, including the starting frame.\ntitle = \"\": The title of the figure.\nshowstep = true: If current step should be shown in title.\nfigure = NamedTuple(): Figure related keywords (e.g. resolution, backgroundcolor).\naxis = NamedTuple(): Axis related keywords (e.g. aspect).\nrecordkwargs = NamedTuple(): Keyword arguments given to Makie.record. You can use (compression = 1, profile = \"high\") for a higher quality output, and prefer the CairoMakie backend. (compression 0 results in videos that are not playable by some software)\nkwargs...: All other keywords are propagated to abmplot.\n\n\n\n\n\n","category":"function"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"E.g., continuing from above,","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"model, daisy_step!, daisyworld_step! = daisyworld()\nabmvideo(\n    \"daisyworld.mp4\",\n    model,  daisy_step!, daisyworld_step!;\n    title = \"Daisy World\", frames = 150,\n    plotkwargs...\n)","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../daisyworld.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"agents/#Agent-inspection-1","page":"Agent Based Models","title":"Agent inspection","text":"","category":"section"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"It is possible to inspect agents at a given position by hovering the mouse cursor over the scatter points in the agent plot. Inspection is automatically enabled for interactive applications (i.e. when either agent or model stepping functions are provided). To manually enable this functionality, simply add enable_inspection = true as an additional keyword argument to the abmplot/abmplot! call. A tooltip will appear which by default provides the name of the agent type, its id, pos, and all other fieldnames together with their current values. This is especially useful for interactive exploration of micro data on the agent level.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"(Image: RabbitFoxHawk inspection example)","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"The tooltip can be customized by extending InteractiveDynamics.agent2string.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"InteractiveDynamics.agent2string","category":"page"},{"location":"agents/#InteractiveDynamics.agent2string","page":"Agent Based Models","title":"InteractiveDynamics.agent2string","text":"agent2string(agent::A)\n\nConvert agent data into a string which is used to display all agent variables and their values in the tooltip on mouse hover. Concatenates strings if there are multiple agents at one position. Custom tooltips for agents can be implemented by adding a specialised method for agent2string. Example:\n\nimport InteractiveDynamics.agent2string\nfunction agent2string(agent::SpecialAgent)\n    \"\"\"\n    ✨ SpecialAgent ✨\n    ID = $(agent.id)\n    Main weapon = $(agent.charisma)\n    Side weapon = $(agent.pistol)\n    \"\"\"\nend\n\n\n\n\n\n","category":"function"},{"location":"agents/#Creating-custom-ABM-plots-1","page":"Agent Based Models","title":"Creating custom ABM plots","text":"","category":"section"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"The existing convenience function abmexploration will always display aggregated collected data as scatterpoints connected with lines. In cases where more granular control over the displayed plots is needed, we need to take a few extra steps and utilize the ABMObservable returned by abmplot.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"ABMObservable","category":"page"},{"location":"agents/#InteractiveDynamics.ABMObservable","page":"Agent Based Models","title":"InteractiveDynamics.ABMObservable","text":"ABMObservable(model; agent_step!, model_step!, adata, mdata, when) → abombs\n\nabmobs contains all information necessary to step an agent based model interactively. It is also returned by abmplot.\n\nCalling Agents.step!(abmobs, n) will step the model for n using the provided agent_step!, model_step!, n as in Agents.step!.\n\nThe fields abmobs.model, abmobs.adf, abmobs.mdf are observables that contain the AgentBasedModel, and the agent and model dataframes with collected data. Data are collected as described in Agents.run! using the adata, mdata, when keywords. All three observables are updated on stepping (when it makes sense). The field abmobs.s is also an observable containing the current step number.\n\nAll plotting and interactivity should be defined by lifting these observables.\n\n\n\n\n\n","category":"type"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"To do custom animations you need to have a good idea of how Makie's animation system works. Have a look at this tutorial if you are not familiar yet.","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"create a basic abmplot with controls and sliders","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"model, = daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)\nfig, ax, abmobs = abmplot(model;\n    agent_step! = daisy_step!, model_step! = daisyworld_step!, params, plotkwargs...,\n    adata, mdata, figure = (; resolution = (1600,800))\n)\nfig","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"abmobs","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"# create a new layout to add new plots to to the right of the abmplot\nplot_layout = fig[:,end+1] = GridLayout()\n\n# create a sublayout on its first row and column\ncount_layout = plot_layout[1,1] = GridLayout()\n\n# collect tuples with x and y values for black and white daisys\nblacks = @lift(Point2f.($(p.adf).step, $(p.adf).count_black))\nwhites = @lift(Point2f.($(p.adf).step, $(p.adf).count_white))\n\n# create an axis to plot into and style it to our liking\nax_counts = Axis(count_layout[1,1];\n    backgroundcolor = :lightgrey, ylabel = \"Number of daisies by color\")\n\n# plot the data as scatterlines and color them accordingly\nscatterlines!(ax_counts, blacks; color = :black, label = \"black\")\nscatterlines!(ax_counts, whites; color = :white, label = \"white\")\n\n# add a legend to the right side of the plot\nLegend(count_layout[1,2], ax_counts; bgcolor = :lightgrey)\n\n# and another plot, written in a more condensed format\nax_hist = Axis(plot_layout[2,1];\n    ylabel = \"Distribution of mean temperatures\\nacross all time steps\")\nhist!(ax_hist, @lift($(p.mdf).temperature);\n    bins = 50, color = :red,\n    strokewidth = 2, strokecolor = (:black, 0.5),\n)\n\nfig","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"Now, once we step the p::ABMObservable, the whole plot will be updated","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"Agents.step!(p, 1)\nAgents.step!(p, 1)\nfig","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"Of course, you need to actually adjust axis limits given that the plot is interactive","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"autolimits!(ax_counts)\nautolimits!(ax_hist)","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"Or, simply trigger them on any update to the model observable:","category":"page"},{"location":"agents/#","page":"Agent Based Models","title":"Agent Based Models","text":"on(p.model) do m\n    autolimits!(ax_counts)\n    autolimits!(ax_hist)\nend\n\nfor i in 1:100; step!(p, 1); end\nfig","category":"page"},{"location":"highlight/#Trajectory-Highlighter-1","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"","category":"section"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"trajectory_highlighter","category":"page"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"2D Version:","category":"page"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/highlighter2D.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"3D Version:","category":"page"},{"location":"highlight/#","page":"Trajectory Highlighter","title":"Trajectory Highlighter","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/highlighter3D.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"dynamicalsystems/#Interactive-GUIs-for-Dynamical-Systems-1","page":"Dynamical Systems","title":"Interactive GUIs for Dynamical Systems","text":"","category":"section"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"Via the package InteractiveDynamics.jl we have created several GUI applications for exploring dynamical systems which are integrated with DynamicalSystems.jl. The GUI apps use the Makie ecosystem, and have been designed to favor generality and simple source code. This means that even if one of the available GUI apps does not do what you'd like to do, it should be easy to copy its source code and adjust accordingly!","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"This documentation page is built using versions:","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"using Pkg\nPkg.status([\"DynamicalSystems\", \"InteractiveDynamics\"];\n    mode = PKGMODE_MANIFEST, io=stdout\n)","category":"page"},{"location":"dynamicalsystems/#Interactive-Trajectory-Evolution-1","page":"Dynamical Systems","title":"Interactive Trajectory Evolution","text":"","category":"section"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_trajectory.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"interactive_evolution","category":"page"},{"location":"dynamicalsystems/#InteractiveDynamics.interactive_evolution","page":"Dynamical Systems","title":"InteractiveDynamics.interactive_evolution","text":"interactive_evolution(ds::DynamicalSystem [, u0s]; kwargs...) → fig, obs, step\n\nLaunch an interactive GUI application that can evolve the initial conditions u0s (vector of vectors) of the given dynamical system. All initial conditions are evolved in parallel and at exactly the same time.\n\nAdded controls allow you to step/run/pause the evolution and to control after how many integrator steps the plots are updated. The application can run forever (trajectories are computed on demand).\n\nBy default the GUI window displays statespace and timeseries plots. It also allows changing the parameters of ds live during the system evolution, see keyword ps below in \"Parameter Keywords\".\n\nThe function returns fig, obs, step, paramvals. fig is the overarching figure (the entire GUI) and can be recorded with Makie.record. obs is a vector of observables, each containing the current state of each trajectory. step is an observable that triggers the stepping of each trajectory and the update of the plots. Do step[] = 0 (or any other integer), to trigger an update. paramvals is an observable containing current parameter values, and is only valid if ps is not nothing, see keyword ps below in \"Parameter Keywords\".\n\nThe figure layout is as follows:\n\nfig[1,1] = state space plot (fig[1,1][1,1]) and time evolution controls\nfig[1,2] = timeseries plots\nfig[2,:] = parameter controls (if ps is given)\n\nThis means that you can make any kind of composite plots and videos starting from the figure returned from interactive_evolution. See the documentation online for more such examples.\n\nState Space Keywords\n\ntransform = identity: Transformation applied to the state of the dynamical system before plotting. Can even return a vector that is of higher dimension than ds.\nidxs = 1:min(length(transform(u0s[1])), 3): Which variables to plot (up to three can be chosen). Variables are selected after transform has been applied.\ncolors: The color for each initial condition (and resulting trajectory).\nlims: A tuple of tuples (min, max) for the axis limits. If not given, they are automatically deduced by evolving each of u0s 1000 units and picking most extreme values (limits are very hard to adjust after application is launched).\nm = 1.0: The trajectory endpoints have a marker. A heuristic is done to choose appropriate marker size given the trajectory size. m is a multiplier that scales the marker size.\ntail = 1000: Length of plotted trajectory (in step units of the integrator).\nfade = true: For continuous time system, the trajectories in state space are faded to full transparency if true.\nplotkwargs = NamedTuple() : A named tuple of keyword arguments propagated to the state space plot (lines for continuous, scatter for discrete systems). plotkwargs can also be a vector of named tuples, in which case each initial condition gets different arguments.\ndiffeq = NamedTuple(): Named tuple of keyword arguments propagated to the solvers of DifferentialEquations.jl (for continuous systems). Because trajectories are not pre-computed and interpolated, but rather calculated on the fly step by step, it is strongly recommended to use an ODE solver thas has a constant step size instead of being adaptive. For example diffeq = (alg=Tsit5(), adaptive=false, dt=0.01).\nadd_controls = true: Whether to add buttons and sliders for interactively controlling the trajectory evolution. Should be false only if composite videos are intended to be produced using the returned step. If false, the keyword steps_per_update = 1 decides how many steps to take before updating plots.\n\nTimeseries Keywords\n\ntsidxs = idxs: Indices selecting variables to be plotted as timeseries. You can pass nothing instead and no timeseries will be plotted.\ntotal_span: How much the x-axis of the timeseries plots should span (in real time units)\nlinekwargs = NamedTuple(): Extra keywords propagated to the timeseries plots.\n\nParameter Keywords\n\nps = nothing: If ps is not nothing, then it must be a dictionary, mapping keys of the system parameter container (ds.p) to possible ranges of values. The app then will add some additional controls on the bottom of the GUI which allow one to interactively change system parameters and then click the \"update\" button to translate the new parameters to system evolution. This can be done without stopping the live system evolution. Notice that in this scenario it is recommended to provide the lims keyword manually. An extra argument is returned in this case: a dictionary mapping parameter keys to observables containing their current values. You can use this to generate additional plot elements that may depend on system parameters and thus need to be changed if the sliders are changed.\npnames = Dict(keys(ps) .=> keys(ps)) : Dictionary mapping parameter keys to labels. Only valid if params is a dictionary and not nothing.\n\nIn addition the keywords figure, axis can be named tuples with arbitrary keywords propagated to the generation of the Figure and state space Axis instances.\n\n\n\n\n\n","category":"function"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"For example, the animation on the top of this section was done with:","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"using InteractiveDynamics\nusing DynamicalSystems, GLMakie\nusing OrdinaryDiffEq\n\ndiffeq = (alg = Tsit5(), adaptive = false, dt = 0.01)\nps = Dict(\n    1 => 1:0.1:30,\n    2 => 10:0.1:50,\n    3 => 1:0.01:10.0,\n)\npnames = Dict(1 => \"σ\", 2 => \"ρ\", 3 => \"β\")\n\nlims = (\n    (-30, 30),\n    (-30, 30),\n    (0, 100),\n)\n\nds = Systems.lorenz()\n\nu1 = [10,20,40.0]\nu3 = [20,10,40.0]\nu0s = [u1, u3]\n\nidxs = (1, 2, 3)\ndiffeq = (alg = Tsit5(), dt = 0.01, adaptive = false)\n\nfigure, obs, step, paramvals = interactive_evolution(\n    ds, u0s; ps, idxs, tail = 1000, diffeq, pnames, lims\n)\n\n# Use the `slidervals` observable to plot fixed points\nlorenzfp(ρ,β) = [\n    Point3f(sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1),\n    Point3f(-sqrt(β*(ρ-1)), -sqrt(β*(ρ-1)), ρ-1),\n]\n\nfpobs = lift(lorenzfp, slidervals[2], slidervals[3])\nax = content(figure[1,1][1,1])\nscatter!(ax, fpobs; markersize = 5000, marker = :diamond, color = :black)","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"Notice that the last part of the code plots the fixed points of the system (something interactive_evolution does not do by itself), and the fixed points plots are automatically updated when a parameter is changed in the GUI, because it uses the observable paramvals.","category":"page"},{"location":"dynamicalsystems/#Customized-animations-1","page":"Dynamical Systems","title":"Customized animations","text":"","category":"section"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"It is straightforward to add custom plots and generate extra animations from the interface of the step observable returned by interactive_evolution. In the following example we'll make a video that rotates around some interlaced periodic trajectories, and plot some stuff from them on an extra panel to the right.","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"using DynamicalSystems, InteractiveDynamics, CairoMakie\nusing OrdinaryDiffEq: Tsit5\nusing LinearAlgebra: dot, norm\n\nds = Systems.thomas_cyclical(b = 0.2)\nu0s = ([3, 1, 1.], [1, 3, 1.], [1, 1, 3.])\ndiffeq = (alg = Tsit5(), adaptive = false, dt = 0.05)\n\nfig, obs, step, = interactive_evolution(\n    ds, u0s; tail = 1000, diffeq, add_controls = false, tsidxs = nothing,\n    # Replace this with [1, 2, 3] if using GLMakie (looks much cooler ;))\n    idxs = [1, 2],\n    figure = (resolution = (1200, 600),),\n)\naxss = content(fig[1,1][1,1])\naxss.title = \"State space (projected)\"\n\n# Plot some stuff on a second axis that use `obs`\n# Plot distance of trajectory from symmetry line\nax = Axis(fig[1,1][1,2]; xlabel = \"points\", ylabel = \"distance\")\nfunction distance_from_symmetry(u)\n    v = 0*SVector(u...) .+ 1/√(length(u))\n    t = dot(v, u)\n    return norm(u - t*v)\nend\nfor (i, ob) in enumerate(obs)\n    y = lift(x -> distance_from_symmetry.(x) .+ 4(i-1), ob)\n    x = 1:length(y[])\n    lines!(ax, x, y; color = JULIADYNAMICS_COLORS[i])\nend\nax.limits = ((0, 1000), (0, 12))\nfig","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"Now we can step this animation arbitrarily many times","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"for j in 1:500; step[] = 0; end\nfig","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"for j in 1:500; step[] = 0; end\nfig","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"Or we could produce a video with:","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"record(fig, \"thomas_cyclical.mp4\"; framerate = 60) do io\n    for i in 1:720\n        recordframe!(io)\n        # Step multiple times per frame for \"faster\" animation\n        for j in 1:5; step[] = 0; end\n    end\nend","category":"page"},{"location":"dynamicalsystems/#Cobweb-Diagrams-1","page":"Dynamical Systems","title":"Cobweb Diagrams","text":"","category":"section"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/cobweb.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"interactive_cobweb","category":"page"},{"location":"dynamicalsystems/#InteractiveDynamics.interactive_cobweb","page":"Dynamical Systems","title":"InteractiveDynamics.interactive_cobweb","text":"interactive_cobweb(ds::DiscreteDynamicalSystem, prange, O::Int = 3; kwargs...)\n\nLaunch an interactive application for exploring cobweb diagrams of 1D discrete dynamical systems. Two slides control the length of the plotted trajectory and the current parameter value. The parameter values are obtained from the given prange.\n\nIn the cobweb plot, higher order iterates of the dynamic rule f are plotted as well, starting from order 1 all the way to the given order O. Both the trajectory in the cobweb, as well as any iterate f can be turned off by using some of the buttons.\n\nKeywords\n\nfkwargs = [(linewidth = 4.0, color = randomcolor()) for i in 1:O]: plotting keywords for each of the plotted iterates of f\ntrajcolor = :black: color of the trajectory\npname = \"p\": name of the parameter slider\npindex = 1: parameter index\nxmin = 0, xmax = 1: limits the state of the dynamical system can take\nTmax = 1000: maximum trajectory length\nx0s = range(xmin, xmax; length = 101): Possible values for the x0 slider.\n\n\n\n\n\n","category":"function"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"The animation at the top of this section was done with","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"using InteractiveDynamics, GLMakie, DynamicalSystems\n\n# the second range is a convenience for intermittency example of logistic\nrrange = 1:0.001:4.0\n# rrange = (rc = 1 + sqrt(8); [rc, rc - 1e-5, rc - 1e-3])\n\nlo = Systems.logistic(0.4; r = rrange[1])\ninteractive_cobweb(lo, rrange, 5)","category":"page"},{"location":"dynamicalsystems/#Orbit-Diagrams-1","page":"Dynamical Systems","title":"Orbit Diagrams","text":"","category":"section"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"Notice that orbit diagrams and bifurcation diagrams are different things in DynamicalSystems.jl","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odhenon.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"interactive_orbitdiagram\nscaleod","category":"page"},{"location":"dynamicalsystems/#InteractiveDynamics.interactive_orbitdiagram","page":"Dynamical Systems","title":"InteractiveDynamics.interactive_orbitdiagram","text":"interactive_orbitdiagram(\n    ds::DiscreteDynamicalSystem, p_index, pmin, pmax, i0 = 1;\n    u0 = get_state(ds), parname = \"p\", title = \"\"\n)\n\nOpen an interactive application for exploring orbit diagrams (ODs) of discrete dynamical systems. Requires DynamicalSystems.\n\nKeywords control the name of the parameter, the initial state (used for any parameter) or whether to add a title above the orbit diagram.\n\nInteraction\n\nThe application is separated in the \"OD plot\" (left) and the \"control panel\" (right). On the OD plot you can interactively click and drag with the left mouse button to select a region in the OD. This region is then re-computed at a higher resolution.\n\nThe options at the control panel are straight-forward, with\n\nn amount of steps recorded for the orbit diagram (not all are in the zoomed region!)\nt transient steps before starting to record steps\nd density of x-axis (the parameter axis)\nα alpha value for the plotted points.\n\nNotice that at each update n*t*d steps are taken. You have to press update after changing these parameters. Press reset to bring the OD in the original state (and variable). Pressing back will go back through the history of your exploration History is stored when the \"update\" button is pressed or a region is zoomed in.\n\nYou can even decide which variable to get the OD for by choosing one of the variables from the wheel! Because the y-axis limits can't be known when changing variable, they reset to the size of the selected variable.\n\nAccessing the data\n\nWhat is plotted on the application window is a true orbit diagram, not a plotting shorthand. This means that all data are obtainable and usable directly. Internally we always scale the orbit diagram to [0,1]² (to allow Float64 precision even though plotting is Float32-based). This however means that it is necessary to transform the data in real scale. This is done through the function scaleod which accepts the 5 arguments returned from the current function:\n\nfigure, oddata = interactive_orbitdiagram(...)\nps, us = scaleod(oddata)\n\n\n\n\n\n","category":"function"},{"location":"dynamicalsystems/#InteractiveDynamics.scaleod","page":"Dynamical Systems","title":"InteractiveDynamics.scaleod","text":"scaleod(oddata) -> ps, us\n\nGiven the return values of interactive_orbitdiagram, produce orbit diagram data scaled correctly in data units. Return the data as a vector of parameter values and a vector of corresponding variable values.\n\n\n\n\n\n","category":"function"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"The animation at the top of this section was done with","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"i = p_index = 1\nds, p_min, p_max, parname = Systems.henon(), 0.8, 1.4, \"a\"\nt = \"orbit diagram for the Hénon map\"\n\noddata = interactive_orbitdiagram(ds, p_index, p_min, p_max, i;\n                                  parname = parname, title = t)\n\nps, us = scaleod(oddata)","category":"page"},{"location":"dynamicalsystems/#Interactive-Poincaré-Surface-of-Section-1","page":"Dynamical Systems","title":"Interactive Poincaré Surface of Section","text":"","category":"section"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_psos.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"interactive_poincaresos","category":"page"},{"location":"dynamicalsystems/#InteractiveDynamics.interactive_poincaresos","page":"Dynamical Systems","title":"InteractiveDynamics.interactive_poincaresos","text":"interactive_poincaresos(cds, plane, idxs, complete; kwargs...)\n\nLaunch an interactive application for exploring a Poincaré surface of section (PSOS) of the continuous dynamical system cds. Requires DynamicalSystems.\n\nThe plane can only be the Tuple type accepted by DynamicalSystems.poincaresos, i.e. (i, r) for the ith variable crossing the value r. idxs gives the two indices of the variables to be displayed, since the PSOS plot is always a 2D scatterplot. I.e. idxs = (1, 2) will plot the 1st versus 2nd variable of the PSOS. It follows that plane[1] ∉ idxs must be true.\n\ncomplete is a three-argument function that completes the new initial state during interactive use, see below.\n\nThe function returns: figure, laststate with the latter being an observable containing the latest initial state.\n\nKeyword Arguments\n\ndirection, rootkw : Same use as in DynamicalSystems.poincaresos.\ntfinal = (1000.0, 10.0^4) : A 2-element tuple for the range of values for the total integration time (chosen interactively).\ncolor : A function of the system's initial condition, that returns a color to plot the new points with. The color must be RGBf/RGBAf.  A random color is chosen by default.\nlabels = (\"u₁\" , \"u₂\") : Scatter plot labels.\nscatterkwargs = (): Named tuple of keywords passed to scatter.\ndiffeq = NamedTuple() : Any extra keyword arguments are passed into init of DiffEq.\n\nInteraction\n\nThe application is a standard scatterplot, which shows the PSOS of the system, initially using the system's u0. Two sliders control the total evolution time and the size of the marker points (which is always in pixels).\n\nUpon clicking within the bounds of the scatter plot your click is transformed into a new initial condition, which is further evolved and its PSOS is computed and then plotted into the scatter plot.\n\nYour click is transformed into a full D-dimensional initial condition through the function complete. The first two arguments of the function are the positions of the click on the PSOS. The third argument is the value of the variable the PSOS is defined on. To be more exact, this is how the function is called:\n\nx, y = mouseclick; z = plane[2]\nnewstate = complete(x, y, z)\n\nThe complete function can throw an error for ill-conditioned x, y, z. This will be properly handled instead of breaking the application. This newstate is also given to the function color that gets a new color for the new points.\n\n\n\n\n\n","category":"function"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"To generate the animation at the start of this section you can run","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"using InteractiveDynamics, GLMakie, OrdinaryDiffEq, DynamicalSystems\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\n\nhh = Systems.henonheiles()\n\npotential(x, y) = 0.5(x^2 + y^2) + (x^2*y - (y^3)/3)\nenergy(x,y,px,py) = 0.5(px^2 + py^2) + potential(x,y)\nconst E = energy(get_state(hh)...)\n\nfunction complete(y, py, x)\n    V = potential(x, y)\n    Ky = 0.5*(py^2)\n    Ky + V ≥ E && error(\"Point has more energy!\")\n    px = sqrt(2(E - V - Ky))\n    ic = [x, y, px, py]\n    return ic\nend\n\nplane = (1, 0.0) # first variable crossing 0\n\n# Coloring points using the Lyapunov exponent\nfunction λcolor(u)\n    λ = lyapunovs(hh, 4000; u0 = u)[1]\n    λmax = 0.1\n    return RGBf(0, 0, clamp(λ/λmax, 0, 1))\nend\n\nstate, scene = interactive_poincaresos(hh, plane, (2, 4), complete;\nlabels = (\"q₂\" , \"p₂\"),  color = λcolor, diffeq...)","category":"page"},{"location":"dynamicalsystems/#Scanning-a-Poincaré-Surface-of-Section-1","page":"Dynamical Systems","title":"Scanning a Poincaré Surface of Section","text":"","category":"section"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/psos_brainscan.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"brainscan_poincaresos","category":"page"},{"location":"dynamicalsystems/#InteractiveDynamics.brainscan_poincaresos","page":"Dynamical Systems","title":"InteractiveDynamics.brainscan_poincaresos","text":"brainscan_poincaresos(A::Dataset, j::Int; kwargs...)\nbrainscan_poincaresos(As::Vector{Dataset}, j::Int; kwargs...)\n\nLaunch an interactive application for scanning a Poincare surface of section of A like a \"brain scan\", where the plane that defines the section can be arbitrarily moved around via a slider. Return figure, ax3D, ax2D.\n\nThe input dataset must be 3 dimensional, and here the crossing plane is always chosen to be when the j-th variable of the dataset crosses a predefined value. The slider automatically gets all possible values the j-th variable can obtain.\n\nIf given multiple datasets, the keyword colors attributes a color to each one, e.g. colors = [JULIADYNAMICS_COLORS[mod1(i, 6)] for i in 1:length(As)].\n\nThe keywords linekw, scatterkw are named tuples that are propagated as keyword arguments to the line and scatter plot respectively, while the keyword direction = -1 is propagated to the function DyamicalSystems.poincaresos.\n\n\n\n\n\n","category":"function"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"The animation at the top of this page was done with","category":"page"},{"location":"dynamicalsystems/#","page":"Dynamical Systems","title":"Dynamical Systems","text":"using GLMakie, DynamicalSystems, InteractiveDynamics\nusing OrdinaryDiffEq\n\nds = Systems.henonheiles()\ndiffeq = (alg = Vern9(),)\nu0s = [\n    [0.0, -0.25, 0.42081, 0.0],\n    [0.0, 0.1, 0.5, 0.0],\n    [0.0, -0.31596, 0.354461, 0.0591255]\n]\ntrs = [trajectory(ds, 10000, u0; diffeq)[:, SVector(1,2,3)] for u0 ∈ u0s]\nfor i in 2:length(u0s)\n    append!(trs[1], trs[i])\nend\n\n# Inputs:\nj = 2 # the dimension of the plane\ntr = trs[1]\n\nbrainscan_poincaresos(tr, j; linekw = (transparency = true,))","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"EditURL = \"https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/main/docs/src/billiards.jl\"","category":"page"},{"location":"billiards/#Visualizations-and-Animations-for-Billiards-1","page":"Billiards","title":"Visualizations and Animations for Billiards","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"All plotting and animating for DynamicalBilliards.jl lies within a few well-defined functions from InteractiveDynamics.jl that use the Makie ecosystem.","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"For static plotting, you can use the function bdplot and bdplot_boundarymap.\nFor interacting/animating, you can use the function bdplot_interactive. This function also allows you to create custom animations, see Custom Billiards Animations.\nFor producing videos of time evolution of particles in a billiard, use bdplot_video.","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"This documentation page is built using versions:","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using Pkg\nPkg.status([\"DynamicalBilliards\", \"InteractiveDynamics\"];\n    mode = PKGMODE_MANIFEST, io=stdout\n)","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/billiards_app.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"billiards/#Plotting-1","page":"Billiards","title":"Plotting","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"bdplot\nbdplot_boundarymap","category":"page"},{"location":"billiards/#InteractiveDynamics.bdplot","page":"Billiards","title":"InteractiveDynamics.bdplot","text":"bdplot(x; kwargs...) → fig, ax\nbdplot!(ax::Axis, x; kwargs...)\n\nPlot an object x from DynamicalBilliards into a given axis (or a new figure). x can be an obstacle, a particle, a vector of particles, or a billiard.\n\nbdplot!(ax,::Axis, o::Obstacle; kwargs...)\n\nKeywords are propagated to lines! or poly!. Functions obfill, obcolor, obls, oblw (not exported) decide global defaults for linecolor, fillcolor, linestyle, linewidth, when plotting obstacles.\n\nbdplot!(ax,::Axis, bd::Billiard; clean = true, kwargs...)\n\nIf clean = true, all axis elements are removed and an equal aspect ratio is establised. Other keywords are propagated to the obstacle plots.\n\nbdplot!(ax,::Axis, bd::Billiard, xmin, xmax, ymin, ymax; kwargs...)\n\nThis call signature plots periodic billiards: it plots bd along its periodic vectors so that it fills the total amount of space specified by xmin, xmax, ymin, ymax.\n\nbdplot!(ax,::Axis, ps::Vector{<:AbstractParticle}; kwargs...)\n\nPlot particles as a scatter plot (positions) and a quiver plot (velocities). Keywords particle_size = 5, velocity_size = 0.05 set the size of plotted particles. Keyword colors = JULIADYNAMICS_CMAP decides the color of the particles, and can be either a colormap or a vector of colors with equal length to ps. The rest of the keywords are propagated to the scatter plot of the particles.\n\n\n\n\n\n","category":"function"},{"location":"billiards/#InteractiveDynamics.bdplot_boundarymap","page":"Billiards","title":"InteractiveDynamics.bdplot_boundarymap","text":"bdplot_boundarymap(bmap, intervals; figkwargs = NamedTuple(), kwargs...)\n\nPlot the output of DynamicalBilliards.boundarymap into an axis that correctly displays information about obstacle arclengths.\n\nAlso works for the parallelized version of boundary map.\n\nKeyword Arguments\n\nfigkwargs = NamedTuple() keywords propagated to Figure.\ncolor : The color to use for the plotted points. Can be either a single color or a vector of colors of length length(bmap), in order to give each initial condition a different color (for parallelized version).\nAll other keywords propagated to scatter!.\n\n\n\n\n\n","category":"function"},{"location":"billiards/#Plotting-an-obstacle-with-keywords-1","page":"Billiards","title":"Plotting an obstacle with keywords","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, CairoMakie\n\nbd = billiard_sinai()\n\nfig, ax = bdplot(bd[2])\nbdplot!(ax, bd[4]; color = \"blue\", linestyle = :dot, linewidth = 5.0)\nbdplot!(ax, bd[1]; color = \"yellow\", strokecolor = \"black\")\nfig","category":"page"},{"location":"billiards/#Plotting-a-billiard-1","page":"Billiards","title":"Plotting a billiard","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, CairoMakie\nbd = billiard_logo()[1]\nfig, ax = bdplot(bd)\nfig","category":"page"},{"location":"billiards/#Plotting-some-particle-trajectories-1","page":"Billiards","title":"Plotting some particle trajectories","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, CairoMakie\n\nbd = billiard_hexagonal_sinai()\np1 = randominside(bd)\np2 = randominside(bd, 1.0)\ncolors = [:red, JULIADYNAMICS_COLORS[1]]\nmarkers = [:circle, :rect]\nfig, ax = bdplot(bd)\nfor (p, c) in zip([p1, p2], colors)\n    x, y = DynamicalBilliards.timeseries!(p, bd, 20)\n    lines!(ax, x, y; color = c)\nend\nbdplot!(ax, [p1, p2]; colors, particle_size = 10, marker = markers)\nfig","category":"page"},{"location":"billiards/#Periodic-billiard-plot-1","page":"Billiards","title":"Periodic billiard plot","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"Rectangle periodicity:","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, CairoMakie\n\nr = 0.25\nbd = billiard_rectangle(2, 1; setting = \"periodic\")\nd = Disk([0.5, 0.5], r)\nd2 = Ellipse([1.5, 0.5], 1.5r, 2r/3)\nbd = Billiard(bd.obstacles..., d, d2)\np = Particle(1.0, 0.5, 0.1)\nxt, yt, vxt, vyt, t = DynamicalBilliards.timeseries!(p, bd, 10)\nfig, ax = bdplot(bd, extrema(xt)..., extrema(yt)...)\nlines!(ax, xt, yt)\nbdplot!(ax, p; velocity_size = 0.1)\nfig","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"Hexagonal periodicity:","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, CairoMakie\n\nbd = billiard_hexagonal_sinai(0.3, 1.50; setting = \"periodic\")\nd = Disk([0.7, 0], 0.2)\nd2 = Antidot([0.7/2, 0.65], 0.35)\nbd = Billiard(bd..., d, d2)\n\np = MagneticParticle(-0.5, 0.5, π/5, 1.0)\n\nxt, yt = DynamicalBilliards.timeseries(p, bd, 10)\nfig, ax = bdplot(bd, extrema(xt)..., extrema(yt)...)\nlines!(ax, xt, yt)\nbdplot!(ax, p; velocity_size = 0.1)\nfig","category":"page"},{"location":"billiards/#Boundary-map-plot-1","page":"Billiards","title":"Boundary map plot","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, CairoMakie\n\nbd = billiard_mushroom()\n\nn = 100 # how many particles to create\nt = 200 # how long to evolve each one\n\nbmap, arcs = parallelize(boundarymap, bd, t, n)\n\ncolors = [randomcolor() for i in 1:n] # random colors\n\nfig, ax = bdplot_boundarymap(bmap, arcs, color = colors)\nfig","category":"page"},{"location":"billiards/#Interactive-GUI-1","page":"Billiards","title":"Interactive GUI","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"bdplot_interactive","category":"page"},{"location":"billiards/#InteractiveDynamics.bdplot_interactive","page":"Billiards","title":"InteractiveDynamics.bdplot_interactive","text":"bdplot_interactive(bd::Billiard, ps::Vector{<:AbstractParticle}; kwargs...)\n\nCreate a new figure with bd plotted, and in it initialize various data for animating the evolution of ps in bd. Return fig, phs, chs, where fig is a figure instance and phs, chs can be used for making custom animations, see below.\n\nKeywords (interactivity-related)\n\nplayback_controls = true: If true, add controls that allow live-interaction with the figure, such as pause/play, reset, and creating new particles by clicking and dragging on the billiard plot.\n\nKeywords (visualization-related)\n\ndt = 0.001: The animation always occurs in steps of time dt. A slider can decide how many steps dt to evolve before updating the plots.\nplot_bmap = false: If true, add a second plot with the boundary map.\ncolors = JULIADYNAMICS_CMAP : If a symbol (colormap name) each particle gets a color from the map. If Vector of length N, each particle gets a color form the vector. If Vector with length < N, linear interpolation across contained colors is done.\ntail_length = 1000: The last tail_length positions of each particle are visualized.\ntail_width = 1: Width of the dtail plot.\nfade = true: Tail color fades away.\nplot_particles = true: Besides their tails, also plot the particles as a scatter and quiver plot.\nparticle_size = 5: Marker size for particle scatter plot.\nvelocity_size = 0.05: Multiplication of particle velocity before plotted as quiver.\nbmap_size = 4: Marker size of boundary map scatter plot.\nbackgroundcolor, resolution: Background color and resolution of the created figure.\nkwargs...: Remaining keywords are propagated to the billiard plotting.\n\nCustom Animations\n\nTwo helper structures are defined for each particle:\n\nParticleHelper: Contains quantities that are updated each dt step: the particle, time elapsed since last collision, total time ellapsed, tail (positions in the last tail_length dt-sized steps).\nCollisionHelper: Contains quantities that are only updated at collisions: index of obstacle to be collided with, time to next collision, total collisions so far, boundary map point at upcoming collision.\n\nThese two helpers are necessary to transform the simulation into real-time stepping (1 step = dt time), instead of the traditional DynamicalBilliards.jl setup of discrete time stepping (1 step = 1 collision).\n\nThe returned phs, chs are two observables, one having vector of ParticleHelpers, the other having vector of CollisionHelpers. Every plotted element is lifted from these observables.\n\nAn exported high-level function bdplot_animstep!(phs, chs, bd, dt; update, intervals) progresses the simulation for one dt step. Users should be using bdplot_animstep! for custom-made animations, examples are shown in the documentation online. The only thing the update keyword does is notify!(phs). You can use false for it if you want to step for several dt steps before updating plot elements. Notice that chs is always notified when collisions occur irrespectively of update. They keyword intervals is nothing by default, but if it is arcintervals(bd) instead, then the boundary map field of chs is also updated at collisions.\n\n\n\n\n\n","category":"function"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/billiards_app.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"For example, the animation above was done with:","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, GLMakie\nl, w, r = 0.5, 0.75, 1.0\nbd = billiard_mushroom(l, w, r)\nN = 20\nps = vcat(\n    [MushroomTools.randomchaotic(l, w, r) for i in 1:N],\n    [MushroomTools.randomregular(l, w, r) for i in 1:N],\n)\ncolors = [i ≤ N ? RGBf(0.1, 0.4 + 0.3rand(), 0) : RGBf(0.4, 0, 0.6 + 0.4rand()) for i in 1:2N]\nfig, phs, chs = bdplot_interactive(bd, ps;\n    colors, plot_bmap = true, bmap_size = 8, tail_length = 2000,\n);","category":"page"},{"location":"billiards/#Custom-Billiards-Animations-1","page":"Billiards","title":"Custom Billiards Animations","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"To do custom animations you need to have a good idea of how Makie's animation system works. Have a look at this tutorial if you are not familiar yet.","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"Following the docstring of bdplot_interactive let's add a couple of new plots that animate some properties of the particles. We start with creating the billiard plot and obtaining the observables:","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, CairoMakie\n\nbd = billiard_stadium(1, 1)\nN = 100\nps = particlebeam(1.0, 0.6, 0, N, 0.001)\nfig, phs, chs = bdplot_interactive(bd, ps; playback_controls=false, resolution = (800, 800));\nnothing #hide","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"Then, we add some axis","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"layout = fig[2,1] = GridLayout()\naxd = Axis(layout[1,1]; ylabel = \"log(⟨d⟩)\", align = Outside())\naxs = Axis(layout[2,1]; ylabel = \"std\", xlabel = \"time\", align = Outside())\nhidexdecorations!(axd; grid = false)\nrowsize!(fig.layout, 1, Auto(2))\nfig","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"Our next step is to create new observables to plot in the new axis, by lifting phs, chs. Let's plot the distance between two particles and the  std of the particle y position.","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using Statistics: std\n# Define observables\nd_p(phs) = log(sum(sqrt(sum(phs[1].p.pos .- phs[j].p.pos).^2) for j in 2:N)/N)\nstd_p(phs) = std(p.p.pos[1] for p in phs)\nt = Observable([0.0]) # Time axis\nd = Observable([d_p(phs[])])\ns = Observable([std_p(phs[])])\n# Trigger observable updates\non(phs) do phs\n    push!(t[], phs[1].T)\n    push!(d[], d_p(phs))\n    push!(s[], std_p(phs))\n    notify.((t, d))\n    autolimits!(axd); autolimits!(axs)\nend\n# Plot observables\nlines!(axd, t, d; color = JULIADYNAMICS_COLORS[1])\nlines!(axs, t, s; color = JULIADYNAMICS_COLORS[2])\nnothing","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"The figure hasn't changed yet of course, but after we step the animation, it does:","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"dt = 0.001\nfor j in 1:1000\n    for i in 1:9\n        bdplot_animstep!(phs, chs, bd, dt; update = false)\n    end\n    bdplot_animstep!(phs, chs, bd, dt; update = true)\nend\nfig","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"Of course, you can produce a video of this using Makie's record function.","category":"page"},{"location":"billiards/#Video-output-1","page":"Billiards","title":"Video output","text":"","category":"section"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"bdplot_video","category":"page"},{"location":"billiards/#InteractiveDynamics.bdplot_video","page":"Billiards","title":"InteractiveDynamics.bdplot_video","text":"bdplot_video(file::String, bd::Billiard, ps::Vector{<:AbstractParticle}; kwargs...)\n\nCreate an animation of ps evolving in bd and save it into file. This function shares all visualization-related keywords with bdplot_interactive. Other keywords are:\n\nsteps = 10: How many dt-steps are taken between producing a new frame.\nframes = 1000: How many frames to produce in total.\nframerate = 60.\n\n\n\n\n\n","category":"function"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"Here is an example that changes plotting defaults to make an animation in the style of 3Blue1Brown.","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"using DynamicalBilliards, InteractiveDynamics, CairoMakie\nBLUE = \"#7BC3DC\"\nBROWN = \"#8D6238\"\ncolors = [BLUE, BROWN]\n# Overwrite default color of obstacles to white (to fit with black background)\nbd = billiard_stadium(1, 1)\nps = particlebeam(1.0, 0.6, 0, 200, 0.01)\n# Notice that keyword `color = :white` is propagated to billiard plot\nbdplot_video(\n    \"3b1billiard.mp4\", bd, ps;\n    frames = 120, colors, dt = 0.01, tail_length = 100,\n    backgroundcolor = :black, framerate = 10, color = :white,\n)","category":"page"},{"location":"billiards/#","page":"Billiards","title":"Billiards","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../3b1billiard.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"InteractiveDynamics is a package that provides applications for interactively exploring dynamical systems. It extends various packages of JuliaDynamics.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: Example animations\nAll of the animations/videos you will see in this documentation are generated by simply running the scripts of the examples folder of InteractiveDynamics.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Here are some examples of what you can do with InteractiveDynamics (see Index below, or the various pages of the side bar for full list of applications)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Dynamical systems","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<video width=\"75%\" height=\"auto\" controls loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odhenon.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Billiards","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<video width=\"75%\" height=\"auto\" controls loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/bmap.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Agent based models","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<video width=\"75%\" height=\"auto\" controls loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#Description-1","page":"Introduction","title":"Description","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"InteractiveDynamics is a Julia package that builds on top of the packages of JuliaDynamics to create interactive applications for dynamical systems of all kinds. It is written exclusively in Julia, taking advantage of the interactive plotting that GLMakie.jl provides. InteractiveDynamics is great for teaching and demonstrations, but we believe that it can also be taken advantage of in research.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The combination of the following properties make InteractiveDynamics a unique software:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"General purpose. Arguably the most unique feature of InteractiveDynamics is that every application it offers works for any dynamical system (for the class it targets). The first app shown in the introduction works for any discrete system (of any dimensions), the second app works for any 2D billiard of any shape, the third app works for any 2D agent based model (in discrete or continuous space). This happens because InteractiveDynamics interfaces existing software for dynamical systems from JuliaDynamics. This means that you can re-use the system that you analyze scientifically and explore it interactively, typically requiring only 5-10 extra lines of code to launch the application.\nFast. Because internally some of the fastest dynamical systems software and some of the fastest plotting software are used, this makes our applications extremely fast, given the amount of computations and plotted data they handle.\nReal data. Everything that is plotted is real. For example, the first application shown plots the true orbit diagram (which means that the alpha value is actually the value of the natural density), instead of a pixelated short-hand that allows faster plotting. Since real-data are computed, they are also returned to the user. This means that if the user finds something interesting at any stage of interacting with the application, they can immediately analyze the results in a more thorough and rigorous manner.\nIn real time.  Most applications of InteractiveChaso calculate everything in real-time. This allows true real time interactivity: at any point some model parameter may change and this change will be immediately reflected into the visualizations. Another important consequence of doing calculations in real time is that all applications of InteractiveDynamics can evolve dynamical systems potentially forever.\nSmall source code The entire source code for e.g. the orbit diagram plot is 200 lines of code, all clear to understand (we hope), allowing one to expand the existing apps, or to make more specialized versions.","category":"page"},{"location":"#Usage-1","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Using InteractiveDynamics is straightforward, and the documentation strings of the exported functions describe in detail their purpose (see the individual pages of the sidebar).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Each application relies on a package of JuliaDynamics, and thus it requires it to run. For example, if you want to use the function interactive_orbitdiagram, then you must also load DynamicalSystems besides InteractiveDynamics, e.g.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using DynamicalSystems, InteractiveDynamics, GLMakie\n\nds = Systems.some_example_system()\n\ninteractive_psos(ds, ...)","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"To install do ]add InteractiveDynamics GLMakie. GLMakie is necessary for providing a plotting backend, since InteractiveDynamics does not install one by default.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"It is expected that you have the latest (stable) versions installed for the library you want to use, e.g. DynamicalSystems.","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Modules = [InteractiveDynamics]\nOrder   = [:function, :type]","category":"page"},{"location":"#Utility-1","page":"Introduction","title":"Utility","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"record_interaction","category":"page"},{"location":"#InteractiveDynamics.record_interaction","page":"Introduction","title":"InteractiveDynamics.record_interaction","text":"record_interaction(file, figure; framerate = 30, total_time = 10)\n\nStart recording whatever interaction is happening on some figure into a video output in file (recommended to end in \".mp4\").\n\nKeywords\n\nframerate = 30\ntotal_time = 10: Time to record for, in seconds\nsleep_time = 1: Time to call sleep() before starting to save.\n\n\n\n\n\n","category":"function"}]
}
