<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Agent Based Models · InteractiveDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">InteractiveDynamics</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../trajectory/">Trajectory Evolution</a></li><li><a class="tocitem" href="../od/">Orbit Diagram</a></li><li><a class="tocitem" href="../cobweb/">Cobweb Diagram</a></li><li><a class="tocitem" href="../psos/">Poincaré Surface of Section</a></li><li><a class="tocitem" href="../brainscan/">Brainscanning PSOS</a></li><li><a class="tocitem" href="../billiards/">Billiards</a></li><li class="is-active"><a class="tocitem" href>Agent Based Models</a><ul class="internal"><li><a class="tocitem" href="#Agent-inspection-1"><span>Agent inspection</span></a></li><li><a class="tocitem" href="#Adding-custom-plots-1"><span>Adding custom plots</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Agent Based Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Agent Based Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/master/docs/src/agents.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Agent-based-models-1"><a class="docs-heading-anchor" href="#Agent-based-models-1">Agent based models</a><a class="docs-heading-anchor-permalink" href="#Agent-based-models-1" title="Permalink"></a></h1><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video><p>This page describes functions that can be used in conjunction with <a href="https://juliadynamics.github.io/Agents.jl/dev/">Agents.jl</a> to animate and interact with agent based models.</p><p>The animation at the start of this page was done by running the <code>examples/daisyworld.jl</code> file, and see also an example application in <a href="https://juliadynamics.github.io/Agents.jl/dev/examples/schelling/">Agents.jl docs</a>.</p><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.abm_plot" href="#InteractiveDynamics.abm_plot"><code>InteractiveDynamics.abm_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abm_plot(model::ABM; kwargs...) → fig, abmstepper
abm_plot!(ax::Axis/Axis3, model::ABM; kwargs...) → abmstepper</code></pre><p>Plot an agent based model by plotting each individual agent as a marker and using the agent&#39;s position field as its location on the plot. Requires <code>Agents</code>.</p><p>Return the overarching <code>fig</code> object, as well as a struct <code>abmstepper</code> that can be used to interactively animate the evolution of the ABM and combine it with other subplots. The figure is not displayed by default, you need to either return <code>fig</code> as a last statement in your functions or simply call <code>display(fig)</code>. Notice that models with <code>DiscreteSpace</code> are plotted starting from 0 to n, with n the space size along each dimension.</p><p>To progress the ABM plot <code>n</code> steps simply do:</p><pre><code class="language-julia">Agents.step!(abmstepper, model, agent_step!, model_step!, n)</code></pre><p>You can still call this function with <code>n=0</code> to update the plot for a new <code>model</code>, without doing any stepping. From <code>fig</code> you can obtain the plotted axis (to e.g. turn off ticks, etc.) using <code>ax = content(fig[1, 1])</code>. See <a href="@ref">Sugarscape</a> for an example of using <code>abmstepper</code> to make an animation of evolving the ABM and a heatmap in parallel with only a few lines of code.</p><p><strong>Agent related keywords</strong></p><ul><li><p><code>ac, as, am</code>: These three keywords decided the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a <em>function</em>, which takes as an input a single argument and ouputs the corresponding value. For example:</p><pre><code class="language-julia"># ac = &quot;#338c54&quot;
ac(a) = a.status == :S ? &quot;#2b2b33&quot; : a.status == :I ? &quot;#bf2642&quot; : &quot;#338c54&quot;
# as = 10
as(a) = 10*randn() + 1
# am = :diamond
am(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect</code></pre><p>Notice that for 2D models, <code>am</code> can be/return a <code>Polygon</code> instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent&#39;s position when creating the polygon. In this case, the keyword <code>as</code> is meaningless, as each polygon has its own size. Use the functions <code>scale, rotate2D</code> to transform this polygon.</p><p>3D models currently do not support having different markers. As a result, <code>am</code> cannot be a function. It should be a <code>Mesh</code> or 3D primitive (such as <code>Sphere</code> or <code>Rect3D</code>).</p></li><li><p><code>scheduler = model.scheduler</code>: decides the plotting order of agents (which matters only if there is overlap).</p></li><li><p><code>offset = nothing</code>: If not <code>nothing</code>, it must be a function taking as an input an agent and outputting an offset position tuple to be added to the agent&#39;s position (which matters only if there is overlap).</p></li><li><p><code>scatterkwargs = ()</code>: Additional keyword arguments propagated to the <code>scatter!</code> call.</p></li></ul><p><strong>Preplot related keywords</strong></p><ul><li><code>heatarray = nothing</code> : A keyword that plots a heatmap over the space. Its values can be standard data accessors given to functions like <code>run!</code>, i.e. either a symbol (directly obtain model property) or a function of the model. The returned data must be a matrix of the same size as the underlying space. For example <code>heatarray = :temperature</code> is used in the <a href="@ref">Daisyworld</a> example. But you could also define <code>f(model) = create_some_matrix_from_model...</code> and set <code>heatarray = f</code>. The heatmap will be updated automatically during model evolution in videos and interactive applications.</li><li><code>heatkwargs = NamedTuple()</code> : Keywords given to <code>Makie.heatmap</code> function if <code>heatarray</code> is not nothing.</li><li><code>static_preplot!</code> : A function <code>f(ax, model)</code> that plots something after the heatmap but before the agents. Notice that you can still make objects of this plot be visible above the agents using a translation in the third dimension like below:<pre><code class="language-julia">function static_preplot!(ax, model)
    obj = scatter!(ax, [50 50]; color = :red) # Show position of teacher
    hidedecorations!(ax) # hide tick labels etc.
    translate!(obj, 0, 0, 5) # be sure that the teacher will be above students
end</code></pre></li></ul><p><strong>Figure related keywords</strong></p><p>These only matter for <code>abm_plot</code> and not for <code>abm_plot!</code>.</p><ul><li><code>resolution = (600, 600)</code>: Resolution of the figure.</li><li><code>backgroundcolor = DEFAULT_BG</code>: Background color of the figure.</li><li><code>axiskwargs = NamedTuple()</code>: Keyword arguments given to the main axis creation for e.g. setting <code>xticksvisible = false</code>.</li><li><code>aspect = DataAspect()</code>: The aspect ratio behavior of the axis.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/1fb35af254e962518df8b345199e66144f26f6b5/src/agents/plots_videos.jl#L3-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.abm_play" href="#InteractiveDynamics.abm_play"><code>InteractiveDynamics.abm_play</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abm_play(model, agent_step! [, model_step!]; kwargs...) → fig, abmstepper</code></pre><p>Launch an interactive application that plots an agent based model and can animate its evolution in real time. Requires <code>Agents</code>.</p><p>The agents are plotted exactly like in <a href="#InteractiveDynamics.abm_plot"><code>abm_plot</code></a>, while the two functions <code>agent_step!, model_step!</code> decide how the model will evolve, as in the standard approach of Agents.jl and its <code>step!</code> function.</p><p>The application has three buttons:</p><ul><li>&quot;step&quot;: advances the simulation once for <code>spu</code> steps.</li><li>&quot;run&quot;: starts/stops the continuous evolution of the model.</li><li>&quot;reset&quot;: resets the model to its original configuration. </li></ul><p>Two sliders control the animation speed: &quot;spu&quot; decides how many model steps should be done before the plot is updated, and &quot;sleep&quot; the <code>sleep()</code> time between updates.</p><p><strong>Keywords</strong></p><ul><li><code>ac, am, as, scheduler, offset, aspect, scatterkwargs</code>: propagated to <a href="#InteractiveDynamics.abm_plot"><code>abm_plot</code></a>.</li><li><code>spu = 1:100</code>: The values of the &quot;spu&quot; slider.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/1fb35af254e962518df8b345199e66144f26f6b5/src/agents/plots_videos.jl#L119-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.abm_video" href="#InteractiveDynamics.abm_video"><code>InteractiveDynamics.abm_video</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abm_video(file, model, agent_step! [, model_step!]; kwargs...)</code></pre><p>This function exports the animated time evolution of an agent based model into a video saved at given path <code>file</code>, by recording the behavior of <a href="#InteractiveDynamics.abm_play"><code>abm_play</code></a> (without sliders). The plotting is identical as in <a href="#InteractiveDynamics.abm_plot"><code>abm_plot</code></a> and applicable keywords are propagated.</p><p><strong>Keywords</strong></p><ul><li><code>spf = 1</code>: Steps-per-frame, i.e. how many times to step the model before recording a new frame.</li><li><code>framerate = 30</code>: The frame rate of the exported video.</li><li><code>frames = 300</code>: How many frames to record in total, including the starting frame.</li><li><code>title = &quot;&quot;</code>: The title of the figure.</li><li><code>showstep = true</code>: If current step should be shown in title.</li><li><code>kwargs...</code>: All other keywords are propagated to <a href="#InteractiveDynamics.abm_plot"><code>abm_plot</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/1fb35af254e962518df8b345199e66144f26f6b5/src/agents/plots_videos.jl#L210-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.abm_data_exploration" href="#InteractiveDynamics.abm_data_exploration"><code>InteractiveDynamics.abm_data_exploration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abm_data_exploration(model::ABM, agent_step!, model_step!, params=Dict(); kwargs...)</code></pre><p>Open an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires <code>Agents</code>.</p><p>The application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in <a href="#InteractiveDynamics.abm_play"><code>abm_play</code></a>, and the arguments <code>model, agent_step!, model_step!</code> are propagated there as-is.</p><p>Calling <code>abm_data_exploration</code> returns: <code>fig, agent_df, model_df</code>. So you can save the figure, but you can also access the collected data (if any).</p><p><strong>Interaction</strong></p><p>Besides the basic time evolution interaction of <a href="#InteractiveDynamics.abm_play"><code>abm_play</code></a>, additional functionality here allows changing model parameters in real time, based on the provided fourth argument <code>params</code>. This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of <code>params</code> is a pair of <code>Symbol</code> to an <code>AbstractVector</code>, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only updated into the actual model when pressing the &quot;update&quot; button.</p><p>The &quot;reset&quot; button resets the model to its original agent and space state but it updates it to the currently selected parameter values. A red vertical line is displayed in the data plots when resetting, for visual guidance.</p><p><strong>Keywords</strong></p><ul><li><code>ac, am, as, scheduler, offset, aspect, scatterkwargs</code>: propagated to <a href="#InteractiveDynamics.abm_plot"><code>abm_plot</code></a>.</li><li><code>adata, mdata</code>: Same as the keyword arguments of <code>Agents.run!</code>, and decide which data of the model/agents will be collected and plotted below the interactive plot. Notice that data collection can only occur on plotted steps (and thus steps not plotted due to &quot;spu&quot; are also not data-collected).</li><li><code>alabels, mlabels</code>: If data are collected from agents or the model with <code>adata, mdata</code>, the corresponding plots have a y-label named after the collected data. Instead, you can give <code>alabels, mlabels</code> (vectors of strings with exactly same length as <code>adata, mdata</code>), and these labels will be used instead.</li><li><code>when = true</code>: When to perform data collection, as in <code>Agents.run!</code>.</li><li><code>spu = 1:100</code>: Values that the &quot;spu&quot; slider will obtain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/1fb35af254e962518df8b345199e66144f26f6b5/src/agents/interactive_parameters.jl#L3-L44">source</a></section></article><h2 id="Agent-inspection-1"><a class="docs-heading-anchor" href="#Agent-inspection-1">Agent inspection</a><a class="docs-heading-anchor-permalink" href="#Agent-inspection-1" title="Permalink"></a></h2><p>It is possible to inspect agents at a given position by hovering the mouse cursor over the scatter points in the agent plot. A tooltip will appear which by default provides the name of the agent type, its <code>id</code>, <code>pos</code>, and all other fieldnames together with their current values. This is especially useful for interactive exploration of micro data on the agent level.</p><p>For this functionality, we draw on the powerful features of Makie&#39;s <a href="https://makie.juliaplots.org/v0.15.1/documentation/inspector/"><code>DataInspector</code></a>.</p><p>The tooltip can be customized both with regards to its content and its style by extending a single function and creating a specialized method for a given <code>A&lt;:AbstractAgent</code>.</p><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.agent2string" href="#InteractiveDynamics.agent2string"><code>InteractiveDynamics.agent2string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">agent2string(agent::A)</code></pre><p>Convert agent data into a string which is used to display all agent variables and their  values in the tooltip on mouse hover. Concatenates strings if there are multiple agents  at one position.</p><p>Custom tooltips for agents can be implemented by adding a specialised method  for <code>agent2string</code>.</p><p>Example:</p><pre><code class="language-julia">function InteractiveDynamics.agent2string(agent::SpecialAgent)
    &quot;&quot;&quot;
    ✨ SpecialAgent ✨
    ID = $(agent.id)
    Main weapon = $(agent.charisma)
    Side weapon = $(agent.pistol)
    &quot;&quot;&quot;
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/1fb35af254e962518df8b345199e66144f26f6b5/src/agents/abmplot.jl#L163-L184">source</a></section></article><h2 id="Adding-custom-plots-1"><a class="docs-heading-anchor" href="#Adding-custom-plots-1">Adding custom plots</a><a class="docs-heading-anchor-permalink" href="#Adding-custom-plots-1" title="Permalink"></a></h2><p>Tracking model variables is already made easy by adding them to the <code>adata</code>/<code>mdata</code> vectors.</p><pre><code class="language-julia">using Agents
using Statistics
using InteractiveDynamics
using GLMakie

# initialise model
model, agent_step!, model_step! = Models.schelling()

# define a parameter slider
params = Dict(:min_to_be_happy =&gt; 1:1:5)

# define data to collect and plot
adata= [(:mood, mean)]

# open the interactive app
fig, adf, mdf = abm_data_exploration(model, agent_step!, model_step!, params; adata)</code></pre><img width="100%" height="auto" alt="Regular interactive app for data exploration" src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/custom_plots.png"><p>This will always display the data as scatterpoints connected with lines. In cases where more granular control over the displayed plots is needed, we need to take a few extra steps. Makie plots have to know which changes in the underlying data to watch. This is done by using <code>Observable</code>s. We can simply add the variable in question as an <code>Observable</code> and update it after each simulation step. This can be done by adding a new stepping function which wraps the original <code>model_step!</code> function and the updating of the <code>Observable</code>&#39;s value.</p><p>For the sake of a simple example, let&#39;s assume we want to add a barplot showing the current amount of happy and unhappy agents in our Schelling segregation model.</p><pre><code class="language-julia"># add the new variable as an observable
happiness = [count(a.mood == false for a in allagents(model)),
    count(a.mood == true for a in allagents(model))] |&gt; Observable

# update its value after each model step
function new_model_step!(model; happiness = happiness)
    model_step!(model)
    happiness[] = [count(a.mood == false for a in allagents(model)),
        count(a.mood == true for a in allagents(model))]
end

# open the interactive app and use the enhanced stepping function as an argument
fig, adf, mdf = abm_data_exploration(model, agent_step!, new_model_step!, params; adata)

# add the desired plot to a newly created column on the right
barplot(fig[:,3], [0,1], happiness; bar_labels = [&quot;Unhappy&quot;, &quot;Happy&quot;])

# as usual, we can also style this new plot to our liking
hidexdecorations!(current_axis())</code></pre><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/custom_plots.mp4?raw=true" type="video/mp4">
</video></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../billiards/">« Billiards</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 27 February 2022 16:53">Sunday 27 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
