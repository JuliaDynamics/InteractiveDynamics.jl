<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dynamical Systems · InteractiveDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">InteractiveDynamics</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Dynamical Systems</a><ul class="internal"><li><a class="tocitem" href="#Interactive-Trajectory-Evolution-1"><span>Interactive Trajectory Evolution</span></a></li><li><a class="tocitem" href="#Cobweb-Diagrams-1"><span>Cobweb Diagrams</span></a></li><li><a class="tocitem" href="#Orbit-Diagrams-1"><span>Orbit Diagrams</span></a></li><li><a class="tocitem" href="#Interactive-Poincaré-Surface-of-Section-1"><span>Interactive Poincaré Surface of Section</span></a></li><li><a class="tocitem" href="#Scanning-a-Poincaré-Surface-of-Section-1"><span>Scanning a Poincaré Surface of Section</span></a></li></ul></li><li><a class="tocitem" href="../billiards/">Billiards</a></li><li><a class="tocitem" href="../agents/">Agent Based Models</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Dynamical Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dynamical Systems</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/master/docs/src/dynamicalsystems.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interactive-GUIs-for-Dynamical-Systems-1"><a class="docs-heading-anchor" href="#Interactive-GUIs-for-Dynamical-Systems-1">Interactive GUIs for Dynamical Systems</a><a class="docs-heading-anchor-permalink" href="#Interactive-GUIs-for-Dynamical-Systems-1" title="Permalink"></a></h1><p>Via the package <a href="https://juliadynamics.github.io/InteractiveDynamics.jl/dev/">InteractiveDynamics.jl</a> we have created several GUI applications for exploring dynamical systems which are integrated with <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/">DynamicalSystems.jl</a>. The GUI apps use the <a href="https://makie.juliaplots.org/stable/">Makie</a> ecosystem, and have been designed to favor generality and simple source code. This means that even if one of the available GUI apps does not do what you&#39;d like to do, it should be easy to copy its source code and adjust accordingly!</p><p>This documentation page is built using versions:</p><pre><code class="language-julia">using Pkg
Pkg.status([&quot;DynamicalSystems&quot;, &quot;InteractiveDynamics&quot;];
    mode = PKGMODE_MANIFEST, io=stdout
)</code></pre><pre><code class="language-none">Status `~/work/InteractiveDynamics.jl/InteractiveDynamics.jl/docs/Manifest.toml`
  [61744808] DynamicalSystems v2.3.2
  [ec714cd0] InteractiveDynamics v0.22.1 `~/work/InteractiveDynamics.jl/InteractiveDynamics.jl`</code></pre><h2 id="Interactive-Trajectory-Evolution-1"><a class="docs-heading-anchor" href="#Interactive-Trajectory-Evolution-1">Interactive Trajectory Evolution</a><a class="docs-heading-anchor-permalink" href="#Interactive-Trajectory-Evolution-1" title="Permalink"></a></h2><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_trajectory.mp4?raw=true" type="video/mp4">
</video><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.interactive_evolution" href="#InteractiveDynamics.interactive_evolution"><code>InteractiveDynamics.interactive_evolution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interactive_evolution(ds::DynamicalSystem [, u0s]; kwargs...) → fig, obs, step</code></pre><p>Launch an interactive GUI application that can evolve the initial conditions <code>u0s</code> (vector of vectors) of the given dynamical system. All initial conditions are evolved in parallel and at exactly the same time using a <code>ParallelDynamicalSystem</code> of <code>ds</code>.</p><p>Added controls allow you to step/run/pause the evolution and to control after how many integrator steps the plots are updated. The application can run forever (trajectories are computed on demand).</p><p>By default the GUI window displays statespace and timeseries plots. It also allows changing the parameters of <code>ds</code> live during the system evolution, see keyword <code>ps</code> below in &quot;Parameter Keywords&quot;.</p><p>The function returns <code>fig, obs, step, paramvals</code>. <code>fig</code> is the overarching figure (the entire GUI) and can be recorded with <code>Makie.record</code>. <code>obs</code> is a vector of observables, each containing the current state of each trajectory. <code>step</code> is an observable that triggers the stepping of each trajectory and the update of the plots. Do <code>step[] = 0</code> (or any other integer), to trigger an update. <code>paramvals</code> is an observable containing current parameter values, and is only valid if <code>ps</code> is not nothing, see keyword <code>ps</code> below in &quot;Parameter Keywords&quot;.</p><p>The figure layout is as follows:</p><ol><li><code>fig[1,1]</code> = state space plot (<code>fig[1,1][1,1]</code>) and time evolution controls</li><li><code>fig[1,2]</code> = timeseries plots</li><li><code>fig[2,:]</code> = parameter controls (if <code>ps</code> is given)</li></ol><p>This means that you can make any kind of composite plots and videos starting from the figure returned from <code>interactive_evolution</code>. See the documentation online for more such examples.</p><p><strong>State Space Keywords</strong></p><ul><li><code>transform = identity</code>: Transformation applied to the state of the dynamical system before plotting. Can even return a vector that is of higher dimension than <code>ds</code>.</li><li><code>idxs = 1:min(length(transform(u0s[1])), 3)</code>: Which variables to plot (up to three can be chosen). Variables are selected after <code>transform</code> has been applied.</li><li><code>colors</code>: The color for each initial condition (and resulting trajectory).</li><li><code>lims</code>: A tuple of tuples (min, max) for the axis limits. If not given, they are automatically deduced by evolving each of <code>u0s</code> 1000 units and picking most extreme values (limits are very hard to adjust after application is launched).</li><li><code>m = 1.0</code>: The trajectory endpoints have a marker. A heuristic is done to choose appropriate marker size given the trajectory size. <code>m</code> is a multiplier that scales the marker size.</li><li><code>tail = 1000</code>: Length of plotted trajectory (in step units of the integrator).</li><li><code>fade = true</code>: For continuous time system, the trajectories in state space are faded to full transparency if <code>true</code>.</li><li><code>plotkwargs = NamedTuple()</code> : A named tuple of keyword arguments propagated to the state space plot (<code>lines</code> for continuous, <code>scatter</code> for discrete systems). <code>plotkwargs</code> can also be a vector of named tuples, in which case each initial condition gets different arguments.</li><li><code>Δt</code>: Time step of time evolution. 1 for discrete time, 0.01 for continuous time systems. Because trajectories are not pre-computed and interpolated, but rather calculated on the fly step by step, a constant step size equal to <code>Δt</code> is enforced internally for continuous time systems.</li><li><code>add_controls = true</code>: Whether to add buttons and sliders for interactively controlling the trajectory evolution. Should be <code>false</code> only if composite videos are intended to be produced using the returned <code>step</code>. If <code>false</code>, the keyword <code>steps_per_update = 1</code> decides how many steps to take before updating plots.</li></ul><p><strong>Timeseries Keywords</strong></p><ul><li><code>tsidxs = idxs</code>: Indices selecting variables to be plotted as timeseries. You can pass <code>nothing</code> instead and no timeseries will be plotted.</li><li><code>total_span</code>: How much the x-axis of the timeseries plots should span (in real time units)</li><li><code>linekwargs = NamedTuple()</code>: Extra keywords propagated to the timeseries plots.</li></ul><p><strong>Parameter Keywords</strong></p><ul><li><code>ps = nothing</code>: If <code>ps</code> is not nothing, then it must be a dictionary, mapping keys of the system parameter container (<code>ds.p</code>) to possible ranges of values. The app then will add some additional controls on the bottom of the GUI which allow one to interactively change system parameters and then click the &quot;update&quot; button to translate the new parameters to system evolution. This can be done without stopping the live system evolution. Notice that in this scenario it is recommended to provide the <code>lims</code> keyword manually. An extra argument is returned in this case: a dictionary mapping parameter keys to <em>observables</em> containing their current values. You can use this to generate additional plot elements that may depend on system parameters and thus need to be changed if the sliders are changed.</li><li><code>pnames = Dict(keys(ps) .=&gt; keys(ps))</code> : Dictionary mapping parameter keys to labels. Only valid if <code>params</code> is a dictionary and not <code>nothing</code>.</li></ul><p>In addition the keywords <code>figure, axis</code> can be named tuples with arbitrary keywords propagated to the generation of the <code>Figure</code> and state space <code>Axis</code> instances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/b91e9c77f58cfed11c23740ad872ff0f2b37df5c/src/chaos/trajanim.jl#L20-L107">source</a></section></article><p>For example, the animation on the top of this section was done with:</p><pre><code class="language-julia">using InteractiveDynamics
using DynamicalSystems, GLMakie
using OrdinaryDiffEq

diffeq = (alg = Tsit5(), adaptive = false, dt = 0.01)
ps = Dict(
    1 =&gt; 1:0.1:30,
    2 =&gt; 10:0.1:50,
    3 =&gt; 1:0.01:10.0,
)
pnames = Dict(1 =&gt; &quot;σ&quot;, 2 =&gt; &quot;ρ&quot;, 3 =&gt; &quot;β&quot;)

lims = (
    (-30, 30),
    (-30, 30),
    (0, 100),
)

ds = Systems.lorenz()

u1 = [10,20,40.0]
u3 = [20,10,40.0]
u0s = [u1, u3]

idxs = (1, 2, 3)
diffeq = (alg = Tsit5(), dt = 0.01, adaptive = false)

figure, obs, step, slidervals = interactive_evolution(
    ds, u0s; ps, idxs, tail = 1000, diffeq, pnames, lims
)

# Use the `slidervals` observable to plot fixed points
lorenzfp(ρ,β) = [
    Point3f(sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1),
    Point3f(-sqrt(β*(ρ-1)), -sqrt(β*(ρ-1)), ρ-1),
]

fpobs = lift(lorenzfp, slidervals[2], slidervals[3])
ax = content(figure[1,1][1,1])
scatter!(ax, fpobs; markersize = 20, marker = :diamond, color = :black)</code></pre><p>Notice that the last part of the code plots the fixed points of the system (something <code>interactive_evolution</code> does not do by itself), and the fixed points plots are automatically updated when a parameter is changed in the GUI, because it uses the observable <code>paramvals</code>.</p><h3 id="Customized-animations-1"><a class="docs-heading-anchor" href="#Customized-animations-1">Customized animations</a><a class="docs-heading-anchor-permalink" href="#Customized-animations-1" title="Permalink"></a></h3><p>It is straightforward to add custom plots and generate extra animations from the interface of the <code>step</code> observable returned by <a href="#InteractiveDynamics.interactive_evolution"><code>interactive_evolution</code></a>. In the following example we&#39;ll make a video that rotates around some interlaced periodic trajectories, and plot some stuff from them on an extra panel to the right.</p><pre><code class="language-">using DynamicalSystems, InteractiveDynamics, CairoMakie
using OrdinaryDiffEq: Tsit5
using LinearAlgebra: dot, norm

ds = Systems.thomas_cyclical(b = 0.2)
u0s = ([3, 1, 1.], [1, 3, 1.], [1, 1, 3.])
diffeq = (alg = Tsit5(), adaptive = false, dt = 0.05)

fig, obs, step, = interactive_evolution(
    ds, u0s; tail = 1000, diffeq, add_controls = false, tsidxs = nothing,
    # Replace this with [1, 2, 3] if using GLMakie (looks much cooler ;))
    idxs = [1, 2],
    figure = (resolution = (1200, 600),),
)
axss = content(fig[1,1][1,1])
axss.title = &quot;State space (projected)&quot;

# Plot some stuff on a second axis that use `obs`
# Plot distance of trajectory from symmetry line
ax = Axis(fig[1,1][1,2]; xlabel = &quot;points&quot;, ylabel = &quot;distance&quot;)
function distance_from_symmetry(u)
    v = 0*SVector(u...) .+ 1/√(length(u))
    t = dot(v, u)
    return norm(u - t*v)
end
for (i, ob) in enumerate(obs)
    y = lift(x -&gt; distance_from_symmetry.(x) .+ 4(i-1), ob)
    x = 1:length(y[])
    lines!(ax, x, y; color = JULIADYNAMICS_COLORS[i])
end
ax.limits = ((0, 1000), (0, 12))
fig</code></pre><p>Now we can step this animation arbitrarily many times</p><pre><code class="language-">for j in 1:500; step[] = 0; end
fig</code></pre><pre><code class="language-">for j in 1:500; step[] = 0; end
fig</code></pre><p>Or we could produce a video with:</p><pre><code class="language-julia">record(fig, &quot;thomas_cyclical.mp4&quot;; framerate = 60) do io
    for i in 1:720
        recordframe!(io)
        # Step multiple times per frame for &quot;faster&quot; animation
        for j in 1:5; step[] = 0; end
    end
end</code></pre><h2 id="Cobweb-Diagrams-1"><a class="docs-heading-anchor" href="#Cobweb-Diagrams-1">Cobweb Diagrams</a><a class="docs-heading-anchor-permalink" href="#Cobweb-Diagrams-1" title="Permalink"></a></h2><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/cobweb.mp4?raw=true" type="video/mp4">
</video><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.interactive_cobweb" href="#InteractiveDynamics.interactive_cobweb"><code>InteractiveDynamics.interactive_cobweb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interactive_cobweb(ds::DiscreteDynamicalSystem, prange, O::Int = 3; kwargs...)</code></pre><p>Launch an interactive application for exploring cobweb diagrams of 1D discrete dynamical systems. Two slides control the length of the plotted trajectory and the current parameter value. The parameter values are obtained from the given <code>prange</code>.</p><p>In the cobweb plot, higher order iterates of the dynamic rule <code>f</code> are plotted as well, starting from order 1 all the way to the given order <code>O</code>. Both the trajectory in the cobweb, as well as any iterate <code>f</code> can be turned off by using some of the buttons.</p><p><strong>Keywords</strong></p><ul><li><code>fkwargs = [(linewidth = 4.0, color = randomcolor()) for i in 1:O]</code>: plotting keywords for each of the plotted iterates of <code>f</code></li><li><code>trajcolor = :black</code>: color of the trajectory</li><li><code>pname = &quot;p&quot;</code>: name of the parameter slider</li><li><code>pindex = 1</code>: parameter index</li><li><code>xmin = 0, xmax = 1</code>: limits the state of the dynamical system can take</li><li><code>Tmax = 1000</code>: maximum trajectory length</li><li><code>x0s = range(xmin, xmax; length = 101)</code>: Possible values for the x0 slider.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/b91e9c77f58cfed11c23740ad872ff0f2b37df5c/src/chaos/cobweb.jl#L3-L23">source</a></section></article><p>The animation at the top of this section was done with</p><pre><code class="language-julia">using InteractiveDynamics, GLMakie, DynamicalSystems

# the second range is a convenience for intermittency example of logistic
rrange = 1:0.001:4.0
# rrange = (rc = 1 + sqrt(8); [rc, rc - 1e-5, rc - 1e-3])

lo = Systems.logistic(0.4; r = rrange[1])
interactive_cobweb(lo, rrange, 5)</code></pre><h2 id="Orbit-Diagrams-1"><a class="docs-heading-anchor" href="#Orbit-Diagrams-1">Orbit Diagrams</a><a class="docs-heading-anchor-permalink" href="#Orbit-Diagrams-1" title="Permalink"></a></h2><p><em>Notice that orbit diagrams and bifurcation diagrams are different things in DynamicalSystems.jl</em></p><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odhenon.mp4?raw=true" type="video/mp4">
</video><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.interactive_orbitdiagram" href="#InteractiveDynamics.interactive_orbitdiagram"><code>InteractiveDynamics.interactive_orbitdiagram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interactive_orbitdiagram(
    ds::DynamicalSystem, p_index, pmin, pmax, i::Int = 1;
    u0 = nothing, parname = &quot;p&quot;, title = &quot;&quot;
)</code></pre><p>Open an interactive application for exploring orbit diagrams (ODs) of discrete dynamical systems. Requires <code>DynamicalSystems</code>.</p><p>In essense, the function presents the output of <code>DynamicalSystems.orbitdiagram</code> of the <code>i</code>th variable of the <code>ds</code>, and allows interactively zooming into it.</p><p>Keywords control the name of the parameter, the initial state (used for <em>any</em> parameter) or whether to add a title above the orbit diagram.</p><p><strong>Interaction</strong></p><p>The application is separated in the &quot;OD plot&quot; (left) and the &quot;control panel&quot; (right). On the OD plot you can interactively click and drag with the left mouse button to select a region in the OD. This region is then <strong>re-computed</strong> at a higher resolution.</p><p>The options at the control panel are straight-forward, with</p><ul><li><code>n</code> amount of steps recorded for the orbit diagram (not all are in the zoomed region!)</li><li><code>t</code> transient steps before starting to record steps</li><li><code>d</code> density of x-axis (the parameter axis)</li><li><code>α</code> alpha value for the plotted points.</li></ul><p>Notice that at each update <code>n*t*d</code> steps are taken. You have to press <code>update</code> after changing these parameters. Press <code>reset</code> to bring the OD in the original state (and variable). Pressing <code>back</code> will go back through the history of your exploration History is stored when the &quot;update&quot; button is pressed or a region is zoomed in.</p><p>You can even decide which variable to get the OD for by choosing one of the variables from the wheel! Because the y-axis limits can&#39;t be known when changing variable, they reset to the size of the selected variable.</p><p><strong>Accessing the data</strong></p><p>What is plotted on the application window is a <em>true</em> orbit diagram, not a plotting shorthand. This means that all data are obtainable and usable directly. Internally we always scale the orbit diagram to [0,1]² (to allow <code>Float64</code> precision even though plotting is <code>Float32</code>-based). This however means that it is necessary to transform the data in real scale. This is done through the function <a href="#InteractiveDynamics.scaleod"><code>scaleod</code></a> which accepts the 5 arguments returned from the current function:</p><pre><code class="language-julia">figure, oddata = interactive_orbitdiagram(...)
ps, us = scaleod(oddata)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/b91e9c77f58cfed11c23740ad872ff0f2b37df5c/src/chaos/orbitdiagram.jl#L4-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.scaleod" href="#InteractiveDynamics.scaleod"><code>InteractiveDynamics.scaleod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scaleod(oddata) -&gt; ps, us</code></pre><p>Given the return values of <a href="#InteractiveDynamics.interactive_orbitdiagram"><code>interactive_orbitdiagram</code></a>, produce orbit diagram data scaled correctly in data units. Return the data as a vector of parameter values and a vector of corresponding variable values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/b91e9c77f58cfed11c23740ad872ff0f2b37df5c/src/chaos/orbitdiagram.jl#L255-L260">source</a></section></article><p>The animation at the top of this section was done with</p><pre><code class="language-julia">i = p_index = 1
ds, p_min, p_max, parname = Systems.henon(), 0.8, 1.4, &quot;a&quot;
t = &quot;orbit diagram for the Hénon map&quot;

oddata = interactive_orbitdiagram(ds, p_index, p_min, p_max, i;
                                  parname = parname, title = t)

ps, us = scaleod(oddata)</code></pre><h2 id="Interactive-Poincaré-Surface-of-Section-1"><a class="docs-heading-anchor" href="#Interactive-Poincaré-Surface-of-Section-1">Interactive Poincaré Surface of Section</a><a class="docs-heading-anchor-permalink" href="#Interactive-Poincaré-Surface-of-Section-1" title="Permalink"></a></h2><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_psos.mp4?raw=true" type="video/mp4">
</video><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.interactive_poincaresos" href="#InteractiveDynamics.interactive_poincaresos"><code>InteractiveDynamics.interactive_poincaresos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interactive_poincaresos(cds, plane, idxs, complete; kwargs...)</code></pre><p>Launch an interactive application for exploring a Poincaré surface of section (PSOS) of the continuous dynamical system <code>cds</code>. Requires <code>DynamicalSystems</code>.</p><p>The <code>plane</code> can only be the <code>Tuple</code> type accepted by <code>DynamicalSystems.poincaresos</code>, i.e. <code>(i, r)</code> for the <code>i</code>th variable crossing the value <code>r</code>. <code>idxs</code> gives the two indices of the variables to be displayed, since the PSOS plot is always a 2D scatterplot. I.e. <code>idxs = (1, 2)</code> will plot the 1st versus 2nd variable of the PSOS. It follows that <code>plane[1] ∉ idxs</code> must be true.</p><p><code>complete</code> is a three-argument <strong>function</strong> that completes the new initial state during interactive use, see below.</p><p>The function returns: <code>figure, laststate</code> with the latter being an observable containing the latest initial <code>state</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>direction, rootkw</code> : Same use as in <code>DynamicalSystems.poincaresos</code>.</li><li><code>tfinal = (1000.0, 10.0^4)</code> : A 2-element tuple for the range of values for the total integration time (chosen interactively).</li><li><code>color</code> : A <strong>function</strong> of the system&#39;s initial condition, that returns a color to plot the new points with. The color must be <code>RGBf/RGBAf</code>.  A random color is chosen by default.</li><li><code>labels = (&quot;u₁&quot; , &quot;u₂&quot;)</code> : Scatter plot labels.</li><li><code>scatterkwargs = ()</code>: Named tuple of keywords passed to <code>scatter</code>.</li><li><code>diffeq = NamedTuple()</code> : Any extra keyword arguments are passed into <code>init</code> of DiffEq.</li></ul><p><strong>Interaction</strong></p><p>The application is a standard scatterplot, which shows the PSOS of the system, initially using the system&#39;s <code>u0</code>. Two sliders control the total evolution time and the size of the marker points (which is always in pixels).</p><p>Upon clicking within the bounds of the scatter plot your click is transformed into a new initial condition, which is further evolved and its PSOS is computed and then plotted into the scatter plot.</p><p>Your click is transformed into a full <code>D</code>-dimensional initial condition through the function <code>complete</code>. The first two arguments of the function are the positions of the click on the PSOS. The third argument is the value of the variable the PSOS is defined on. To be more exact, this is how the function is called:</p><pre><code class="language-julia">x, y = mouseclick; z = plane[2]
newstate = complete(x, y, z)</code></pre><p>The <code>complete</code> function can throw an error for ill-conditioned <code>x, y, z</code>. This will be properly handled instead of breaking the application. This <code>newstate</code> is also given to the function <code>color</code> that gets a new color for the new points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/b91e9c77f58cfed11c23740ad872ff0f2b37df5c/src/chaos/poincareclick.jl#L4-L53">source</a></section></article><p>To generate the animation at the start of this section you can run</p><pre><code class="language-julia">using InteractiveDynamics, GLMakie, OrdinaryDiffEq, DynamicalSystems
diffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)

hh = Systems.henonheiles()

potential(x, y) = 0.5(x^2 + y^2) + (x^2*y - (y^3)/3)
energy(x,y,px,py) = 0.5(px^2 + py^2) + potential(x,y)
const E = energy(get_state(hh)...)

function complete(y, py, x)
    V = potential(x, y)
    Ky = 0.5*(py^2)
    Ky + V ≥ E &amp;&amp; error(&quot;Point has more energy!&quot;)
    px = sqrt(2(E - V - Ky))
    ic = [x, y, px, py]
    return ic
end

plane = (1, 0.0) # first variable crossing 0

# Coloring points using the Lyapunov exponent
function λcolor(u)
    λ = lyapunovs(hh, 4000; u0 = u)[1]
    λmax = 0.1
    return RGBf(0, 0, clamp(λ/λmax, 0, 1))
end

state, scene = interactive_poincaresos(hh, plane, (2, 4), complete;
labels = (&quot;q₂&quot; , &quot;p₂&quot;),  color = λcolor, diffeq...)</code></pre><h2 id="Scanning-a-Poincaré-Surface-of-Section-1"><a class="docs-heading-anchor" href="#Scanning-a-Poincaré-Surface-of-Section-1">Scanning a Poincaré Surface of Section</a><a class="docs-heading-anchor-permalink" href="#Scanning-a-Poincaré-Surface-of-Section-1" title="Permalink"></a></h2><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/psos_brainscan.mp4?raw=true" type="video/mp4">
</video><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.brainscan_poincaresos" href="#InteractiveDynamics.brainscan_poincaresos"><code>InteractiveDynamics.brainscan_poincaresos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">brainscan_poincaresos(A::Dataset, j::Int; kwargs...)
brainscan_poincaresos(As::Vector{Dataset}, j::Int; kwargs...)</code></pre><p>Launch an interactive application for scanning a Poincare surface of section of <code>A</code> like a &quot;brain scan&quot;, where the plane that defines the section can be arbitrarily moved around via a slider. Return <code>figure, ax3D, ax2D</code>.</p><p>The input dataset must be 3 dimensional, and here the crossing plane is always chosen to be when the <code>j</code>-th variable of the dataset crosses a predefined value. The slider automatically gets all possible values the <code>j</code>-th variable can obtain.</p><p>If given multiple datasets, the keyword <code>colors</code> attributes a color to each one, e.g. <code>colors = [JULIADYNAMICS_COLORS[mod1(i, 6)] for i in 1:length(As)]</code>.</p><p>The keywords <code>linekw, scatterkw</code> are named tuples that are propagated as keyword arguments to the line and scatter plot respectively, while the keyword <code>direction = -1</code> is propagated to the function <code>DyamicalSystems.poincaresos</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/InteractiveDynamics.jl/blob/b91e9c77f58cfed11c23740ad872ff0f2b37df5c/src/chaos/brainscan.jl#L3-L20">source</a></section></article><p>The animation at the top of this page was done with</p><pre><code class="language-julia">using GLMakie, DynamicalSystems, InteractiveDynamics
using OrdinaryDiffEq

ds = Systems.henonheiles()
diffeq = (alg = Vern9(),)
u0s = [
    [0.0, -0.25, 0.42081, 0.0],
    [0.0, 0.1, 0.5, 0.0],
    [0.0, -0.31596, 0.354461, 0.0591255]
]
trs = [trajectory(ds, 10000, u0; diffeq)[:, SVector(1,2,3)] for u0 ∈ u0s]
for i in 2:length(u0s)
    append!(trs[1], trs[i])
end

# Inputs:
j = 2 # the dimension of the plane
tr = trs[1]

brainscan_poincaresos(tr, j; linekw = (transparency = true,))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../billiards/">Billiards »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 26 February 2023 15:16">Sunday 26 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
